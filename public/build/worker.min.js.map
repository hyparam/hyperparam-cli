{"version":3,"file":"worker.min.js","sources":["../../node_modules/hyparquet/src/constants.js","../../node_modules/hyparquet/src/convert.js","../../node_modules/hyparquet/src/schema.js","../../node_modules/hyparquet/src/thrift.js","../../node_modules/hyparquet/src/metadata.js","../../node_modules/hyparquet/src/assemble.js","../../node_modules/hyparquet/src/encoding.js","../../node_modules/hyparquet/src/plain.js","../../node_modules/hyparquet/src/snappy.js","../../node_modules/hyparquet/src/datapage.js","../../node_modules/hyparquet/src/delta.js","../../node_modules/hyparquet/src/datapageV2.js","../../node_modules/hyparquet/src/header.js","../../node_modules/hyparquet/src/utils.js","../../node_modules/hyparquet/src/column.js","../../node_modules/hyparquet/src/read.js","../../node_modules/hyparquet/src/query.js","../../node_modules/hyparquet/src/hyparquet.js","../../node_modules/fzstd/esm/index.mjs","../../node_modules/hysnappy/hysnappy.js","../../node_modules/hyparquet-compressors/src/brotliBitReader.js","../../node_modules/hyparquet-compressors/src/brotliContext.js","../../node_modules/hyparquet-compressors/src/brotliHuffman.js","../../node_modules/hyparquet-compressors/src/brotliPrefix.js","../../node_modules/hyparquet-compressors/src/brotliStreams.js","../../node_modules/hyparquet-compressors/src/gzip.js","../../node_modules/hyparquet-compressors/src/brotliDictionary.js","../../node_modules/hyparquet-compressors/src/brotliTransform.js","../../node_modules/hyparquet-compressors/src/brotli.js","../../node_modules/hyparquet-compressors/src/lz4.js","../../node_modules/hyparquet-compressors/src/index.js","../../src/workers/parquetWorker.ts"],"sourcesContent":["/** @type {import('./types.js').ParquetType[]} */\nexport const ParquetType = [\n  'BOOLEAN',\n  'INT32',\n  'INT64',\n  'INT96', // deprecated\n  'FLOAT',\n  'DOUBLE',\n  'BYTE_ARRAY',\n  'FIXED_LEN_BYTE_ARRAY',\n]\n\nexport const Encoding = [\n  'PLAIN',\n  undefined,\n  'PLAIN_DICTIONARY',\n  'RLE',\n  'BIT_PACKED', // deprecated\n  'DELTA_BINARY_PACKED',\n  'DELTA_LENGTH_BYTE_ARRAY',\n  'DELTA_BYTE_ARRAY',\n  'RLE_DICTIONARY',\n  'BYTE_STREAM_SPLIT',\n]\n\nexport const FieldRepetitionType = [\n  'REQUIRED',\n  'OPTIONAL',\n  'REPEATED',\n]\n\n/** @type {import('./types.js').ConvertedType[]} */\nexport const ConvertedType = [\n  'UTF8',\n  'MAP',\n  'MAP_KEY_VALUE',\n  'LIST',\n  'ENUM',\n  'DECIMAL',\n  'DATE',\n  'TIME_MILLIS',\n  'TIME_MICROS',\n  'TIMESTAMP_MILLIS',\n  'TIMESTAMP_MICROS',\n  'UINT_8',\n  'UINT_16',\n  'UINT_32',\n  'UINT_64',\n  'INT_8',\n  'INT_16',\n  'INT_32',\n  'INT_64',\n  'JSON',\n  'BSON',\n  'INTERVAL',\n]\n\n/** @type {import('./types.js').LogicalTypeType[]} */\nexport const logicalTypeType = [\n  'NULL',\n  'STRING',\n  'MAP',\n  'LIST',\n  'ENUM',\n  'DECIMAL',\n  'DATE',\n  'TIME',\n  'TIMESTAMP',\n  'INTERVAL',\n  'INTEGER',\n  'NULL',\n  'JSON',\n  'BSON',\n  'UUID',\n]\n\nexport const CompressionCodec = [\n  'UNCOMPRESSED',\n  'SNAPPY',\n  'GZIP',\n  'LZO',\n  'BROTLI',\n  'LZ4',\n  'ZSTD',\n  'LZ4_RAW',\n]\n\n/** @type {import('./types.js').PageType[]} */\nexport const PageType = [\n  'DATA_PAGE',\n  'INDEX_PAGE',\n  'DICTIONARY_PAGE',\n  'DATA_PAGE_V2',\n]\n\n/** @type {import('./types.js').BoundaryOrder[]} */\nexport const BoundaryOrder = [\n  'UNORDERED',\n  'ASCENDING',\n  'DESCENDING',\n]\n","const dayMillis = 86400000 // 1 day in milliseconds\n\n/**\n * Convert known types from primitive to rich, and dereference dictionary.\n *\n * @typedef {import('./types.js').DecodedArray} DecodedArray\n * @typedef {import('./types.js').SchemaElement} SchemaElement\n * @param {DecodedArray} data series of primitive types\n * @param {DecodedArray | undefined} dictionary\n * @param {SchemaElement} schemaElement\n * @param {import('./types.js').Encoding} encoding\n * @param {boolean | undefined} utf8 decode bytes as utf8?\n * @returns {DecodedArray} series of rich types\n */\nexport function convertWithDictionary(data, dictionary, schemaElement, encoding, utf8 = true) {\n  if (dictionary && encoding.endsWith('_DICTIONARY')) {\n    // convert dictionary\n    dictionary = convert(dictionary, schemaElement, utf8)\n    let output = data\n    if (data instanceof Uint8Array && !(dictionary instanceof Uint8Array)) {\n      // @ts-expect-error upgrade data to match dictionary type with fancy constructor\n      output = new dictionary.constructor(data.length)\n    }\n    for (let i = 0; i < data.length; i++) {\n      output[i] = dictionary[data[i]]\n    }\n    return output\n  } else {\n    return convert(data, schemaElement, utf8)\n  }\n}\n\n/**\n * Convert known types from primitive to rich.\n *\n * @param {DecodedArray} data series of primitive types\n * @param {SchemaElement} schemaElement\n * @param {boolean | undefined} utf8 decode bytes as utf8?\n * @returns {DecodedArray} series of rich types\n */\nexport function convert(data, schemaElement, utf8 = true) {\n  const ctype = schemaElement.converted_type\n  if (ctype === 'DECIMAL') {\n    const scale = schemaElement.scale || 0\n    const factor = Math.pow(10, -scale)\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      if (data[0] instanceof Uint8Array) {\n        arr[i] = parseDecimal(data[i]) * factor\n      } else {\n        arr[i] = Number(data[i]) * factor\n      }\n    }\n    return arr\n  }\n  if (ctype === undefined && schemaElement.type === 'INT96') {\n    return Array.from(data).map(parseInt96Date)\n  }\n  if (ctype === 'DATE') {\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = new Date(data[i] * dayMillis)\n    }\n    return arr\n  }\n  if (ctype === 'TIMESTAMP_MILLIS') {\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = new Date(Number(data[i]))\n    }\n    return arr\n  }\n  if (ctype === 'TIMESTAMP_MICROS') {\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = new Date(Number(data[i] / 1000n))\n    }\n    return arr\n  }\n  if (ctype === 'JSON') {\n    const decoder = new TextDecoder()\n    return data.map(v => JSON.parse(decoder.decode(v)))\n  }\n  if (ctype === 'BSON') {\n    throw new Error('parquet bson not supported')\n  }\n  if (ctype === 'INTERVAL') {\n    throw new Error('parquet interval not supported')\n  }\n  if (ctype === 'UTF8' || utf8 && schemaElement.type === 'BYTE_ARRAY') {\n    const decoder = new TextDecoder()\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = data[i] && decoder.decode(data[i])\n    }\n    return arr\n  }\n  if (ctype === 'UINT_64') {\n    const arr = new BigUint64Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = BigInt(data[i])\n    }\n    return arr\n  }\n  if (schemaElement.logical_type?.type === 'FLOAT16') {\n    return Array.from(data).map(parseFloat16)\n  }\n  if (schemaElement.logical_type?.type === 'TIMESTAMP') {\n    const { unit } = schemaElement.logical_type\n    let factor = 1n\n    if (unit === 'MICROS') factor = 1000n\n    if (unit === 'NANOS') factor = 1000000n\n    const arr = new Array(data.length)\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = new Date(Number(data[i] / factor))\n    }\n    return arr\n  }\n  return data\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nexport function parseDecimal(bytes) {\n  // TODO: handle signed\n  let value = 0\n  for (const byte of bytes) {\n    value = value << 8 | byte\n  }\n  return value\n}\n\n/**\n * @param {bigint} value\n * @returns {Date}\n */\nfunction parseInt96Date(value) {\n  const days = Number((value >> 64n) - 2440588n)\n  const nano = Number((value & 0xffffffffffffffffn) / 1000000n)\n  const millis = days * dayMillis + nano\n  return new Date(millis)\n}\n\n/**\n * @param {Uint8Array | undefined} bytes\n * @returns {number | undefined}\n */\nexport function parseFloat16(bytes) {\n  if (!bytes) return undefined\n  const int16 = bytes[1] << 8 | bytes[0]\n  const sign = int16 >> 15 ? -1 : 1\n  const exp = int16 >> 10 & 0x1f\n  const frac = int16 & 0x3ff\n  if (exp === 0) return sign * Math.pow(2, -14) * (frac / 1024) // subnormals\n  if (exp === 0x1f) return frac ? NaN : sign * Infinity\n  return sign * Math.pow(2, exp - 15) * (1 + frac / 1024)\n}\n","/**\n * Build a tree from the schema elements.\n *\n * @typedef {import('./types.js').SchemaElement} SchemaElement\n * @typedef {import('./types.js').SchemaTree} SchemaTree\n * @param {SchemaElement[]} schema\n * @param {number} rootIndex index of the root element\n * @param {string[]} path path to the element\n * @returns {SchemaTree} tree of schema elements\n */\nfunction schemaTree(schema, rootIndex, path) {\n  const element = schema[rootIndex]\n  const children = []\n  let count = 1\n\n  // Read the specified number of children\n  if (element.num_children) {\n    while (children.length < element.num_children) {\n      const childElement = schema[rootIndex + count]\n      const child = schemaTree(schema, rootIndex + count, [...path, childElement.name])\n      count += child.count\n      children.push(child)\n    }\n  }\n\n  return { count, element, children, path }\n}\n\n/**\n * Get schema elements from the root to the given element name.\n *\n * @param {SchemaElement[]} schema\n * @param {string[]} name path to the element\n * @returns {SchemaTree[]} list of schema elements\n */\nexport function getSchemaPath(schema, name) {\n  let tree = schemaTree(schema, 0, [])\n  const path = [tree]\n  for (const part of name) {\n    const child = tree.children.find(child => child.element.name === part)\n    if (!child) throw new Error(`parquet schema element not found: ${name}`)\n    path.push(child)\n    tree = child\n  }\n  return path\n}\n\n/**\n * Get the max repetition level for a given schema path.\n *\n * @param {SchemaTree[]} schemaPath\n * @returns {number} max repetition level\n */\nexport function getMaxRepetitionLevel(schemaPath) {\n  let maxLevel = 0\n  for (const { element } of schemaPath) {\n    if (element.repetition_type === 'REPEATED') {\n      maxLevel++\n    }\n  }\n  return maxLevel\n}\n\n/**\n * Get the max definition level for a given schema path.\n *\n * @param {SchemaTree[]} schemaPath\n * @returns {number} max definition level\n */\nexport function getMaxDefinitionLevel(schemaPath) {\n  let maxLevel = 0\n  for (const { element } of schemaPath.slice(1)) {\n    if (element.repetition_type !== 'REQUIRED') {\n      maxLevel++\n    }\n  }\n  return maxLevel\n}\n\n/**\n * Check if a column is list-like.\n *\n * @param {SchemaTree} schema\n * @returns {boolean} true if list-like\n */\nexport function isListLike(schema) {\n  if (!schema) return false\n  if (schema.element.converted_type !== 'LIST') return false\n  if (schema.children.length > 1) return false\n\n  const firstChild = schema.children[0]\n  if (firstChild.children.length > 1) return false\n  if (firstChild.element.repetition_type !== 'REPEATED') return false\n\n  return true\n}\n\n/**\n * Check if a column is map-like.\n *\n * @param {SchemaTree} schema\n * @returns {boolean} true if map-like\n */\nexport function isMapLike(schema) {\n  if (!schema) return false\n  if (schema.element.converted_type !== 'MAP') return false\n  if (schema.children.length > 1) return false\n\n  const firstChild = schema.children[0]\n  if (firstChild.children.length !== 2) return false\n  if (firstChild.element.repetition_type !== 'REPEATED') return false\n\n  const keyChild = firstChild.children.find(child => child.element.name === 'key')\n  if (keyChild?.element.repetition_type === 'REPEATED') return false\n\n  const valueChild = firstChild.children.find(child => child.element.name === 'value')\n  if (valueChild?.element.repetition_type === 'REPEATED') return false\n\n  return true\n}\n","// TCompactProtocol types\nconst CompactType = {\n  STOP: 0,\n  TRUE: 1,\n  FALSE: 2,\n  BYTE: 3,\n  I16: 4,\n  I32: 5,\n  I64: 6,\n  DOUBLE: 7,\n  BINARY: 8,\n  LIST: 9,\n  SET: 10,\n  MAP: 11,\n  STRUCT: 12,\n  UUID: 13,\n}\n\n/**\n * Parse TCompactProtocol\n *\n * @typedef {import(\"./types.d.ts\").DataReader} DataReader\n * @param {DataReader} reader\n * @returns {Record<string, any>}\n */\nexport function deserializeTCompactProtocol(reader) {\n  let lastFid = 0\n  /** @type {Record<string, any>} */\n  const value = {}\n\n  while (reader.offset < reader.view.byteLength) {\n    // Parse each field based on its type and add to the result object\n    const [type, fid, newLastFid] = readFieldBegin(reader, lastFid)\n    lastFid = newLastFid\n\n    if (type === CompactType.STOP) {\n      break\n    }\n\n    // Handle the field based on its type\n    value[`field_${fid}`] = readElement(reader, type)\n  }\n\n  return value\n}\n\n/**\n * Read a single element based on its type\n *\n * @param {DataReader} reader\n * @param {number} type\n * @returns {any} value\n */\nfunction readElement(reader, type) {\n  switch (type) {\n  case CompactType.TRUE:\n    return true\n  case CompactType.FALSE:\n    return false\n  case CompactType.BYTE:\n    // read byte directly\n    return reader.view.getInt8(reader.offset++)\n  case CompactType.I16:\n  case CompactType.I32:\n    return readZigZag(reader)\n  case CompactType.I64:\n    return readZigZagBigInt(reader)\n  case CompactType.DOUBLE: {\n    const value = reader.view.getFloat64(reader.offset, true)\n    reader.offset += 8\n    return value\n  }\n  case CompactType.BINARY: {\n    const stringLength = readVarInt(reader)\n    const strBytes = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, stringLength)\n    reader.offset += stringLength\n    return strBytes\n  }\n  case CompactType.LIST: {\n    const [elemType, listSize] = readCollectionBegin(reader)\n    const boolType = elemType === CompactType.TRUE || elemType === CompactType.FALSE\n    const values = new Array(listSize)\n    for (let i = 0; i < listSize; i++) {\n      values[i] = boolType ? readElement(reader, CompactType.BYTE) === 1 : readElement(reader, elemType)\n    }\n    return values\n  }\n  case CompactType.STRUCT: {\n    /** @type {Record<string, any>} */\n    const structValues = {}\n    let structLastFid = 0\n    while (true) {\n      let structFieldType, structFid\n      [structFieldType, structFid, structLastFid] = readFieldBegin(reader, structLastFid)\n      if (structFieldType === CompactType.STOP) {\n        break\n      }\n      structValues[`field_${structFid}`] = readElement(reader, structFieldType)\n    }\n    return structValues\n  }\n  // TODO: MAP and SET\n  case CompactType.UUID: {\n    // Read 16 bytes to uuid string\n    let uuid = ''\n    for (let i = 0; i < 16; i++) {\n      uuid += reader.view.getUint8(reader.offset++).toString(16).padStart(2, '0')\n    }\n    return uuid\n  }\n  default:\n    throw new Error(`thrift unhandled type: ${type}`)\n  }\n}\n\n/**\n * Var int, also known as Unsigned LEB128.\n * Var ints take 1 to 5 bytes (int32) or 1 to 10 bytes (int64).\n * Reads groups of 7 low bits until high bit is 0.\n *\n * @param {DataReader} reader\n * @returns {number} value\n */\nexport function readVarInt(reader) {\n  let result = 0\n  let shift = 0\n  while (true) {\n    const byte = reader.view.getUint8(reader.offset++)\n    result |= (byte & 0x7f) << shift\n    if (!(byte & 0x80)) {\n      return result\n    }\n    shift += 7\n  }\n}\n\n/**\n * Read a varint as a bigint.\n *\n * @param {DataReader} reader\n * @returns {bigint} value\n */\nfunction readVarBigInt(reader) {\n  let result = 0n\n  let shift = 0n\n  while (true) {\n    const byte = reader.view.getUint8(reader.offset++)\n    result |= BigInt(byte & 0x7f) << shift\n    if (!(byte & 0x80)) {\n      return result\n    }\n    shift += 7n\n  }\n}\n\n/**\n * Values of type int32 and int64 are transformed to a zigzag int.\n * A zigzag int folds positive and negative numbers into the positive number space.\n *\n * @param {DataReader} reader\n * @returns {number} value\n */\nfunction readZigZag(reader) {\n  const zigzag = readVarInt(reader)\n  // convert zigzag to int\n  return zigzag >>> 1 ^ -(zigzag & 1)\n}\n\n/**\n * A zigzag int folds positive and negative numbers into the positive number space.\n * This version returns a BigInt.\n *\n * @param {DataReader} reader\n * @returns {bigint} value\n */\nexport function readZigZagBigInt(reader) {\n  const zigzag = readVarBigInt(reader)\n  // convert zigzag to int\n  return zigzag >> BigInt(1) ^ -(zigzag & BigInt(1))\n}\n\n/**\n * Get thrift type from half a byte\n *\n * @param {number} byte\n * @returns {number}\n */\nfunction getCompactType(byte) {\n  return byte & 0x0f\n}\n\n/**\n * Read field type and field id\n *\n * @param {DataReader} reader\n * @param {number} lastFid\n * @returns {[number, number, number]} [type, fid, newLastFid]\n */\nfunction readFieldBegin(reader, lastFid) {\n  const type = reader.view.getUint8(reader.offset++)\n  if ((type & 0x0f) === CompactType.STOP) {\n    // STOP also ends a struct\n    return [0, 0, lastFid]\n  }\n  const delta = type >> 4\n  let fid // field id\n  if (delta) {\n    // add delta to last field id\n    fid = lastFid + delta\n  } else {\n    throw new Error('non-delta field id not supported')\n  }\n  return [getCompactType(type), fid, fid]\n}\n\n/**\n * Read collection type and size\n *\n * @param {DataReader} reader\n * @returns {[number, number]} [type, size]\n */\nfunction readCollectionBegin(reader) {\n  const sizeType = reader.view.getUint8(reader.offset++)\n  const size = sizeType >> 4\n  const type = getCompactType(sizeType)\n  if (size === 15) {\n    const newSize = readVarInt(reader)\n    return [type, newSize]\n  }\n  return [type, size]\n}\n\n/**\n * Convert int to varint. Outputs 1-5 bytes for int32.\n *\n * @param {number} n\n * @returns {number[]}\n */\nexport function toVarInt(n) {\n  let idx = 0\n  const varInt = []\n  while (true) {\n    if ((n & ~0x7f) === 0) {\n      varInt[idx++] = n\n      break\n    } else {\n      varInt[idx++] = n & 0x7f | 0x80\n      n >>>= 7\n    }\n  }\n  return varInt\n}\n","import { CompressionCodec, ConvertedType, Encoding, FieldRepetitionType, PageType, ParquetType } from './constants.js'\nimport { parseDecimal, parseFloat16 } from './convert.js'\nimport { getSchemaPath } from './schema.js'\nimport { deserializeTCompactProtocol } from './thrift.js'\n\n/**\n * Read parquet metadata from an async buffer.\n *\n * An AsyncBuffer is like an ArrayBuffer, but the slices are loaded\n * asynchronously, possibly over the network.\n *\n * You must provide the byteLength of the buffer, typically from a HEAD request.\n *\n * In theory, you could use suffix-range requests to fetch the end of the file,\n * and save a round trip. But in practice, this doesn't work because chrome\n * deems suffix-range requests as a not-safe-listed header, and will require\n * a pre-flight. So the byteLength is required.\n *\n * To make this efficient, we initially request the last 512kb of the file,\n * which is likely to contain the metadata. If the metadata length exceeds the\n * initial fetch, 512kb, we request the rest of the metadata from the AsyncBuffer.\n *\n * This ensures that we either make one 512kb initial request for the metadata,\n * or a second request for up to the metadata size.\n *\n * @typedef {import(\"./types.d.ts\").AsyncBuffer} AsyncBuffer\n * @typedef {import(\"./types.d.ts\").FileMetaData} FileMetaData\n * @typedef {import(\"./types.d.ts\").SchemaElement} SchemaElement\n * @param {AsyncBuffer} asyncBuffer parquet file contents\n * @param {number} initialFetchSize initial fetch size in bytes\n * @returns {Promise<FileMetaData>} parquet metadata object\n */\nexport async function parquetMetadataAsync(asyncBuffer, initialFetchSize = 1 << 19 /* 512kb */) {\n  if (!asyncBuffer) throw new Error('parquet file is required')\n  if (!(asyncBuffer.byteLength >= 0)) throw new Error('parquet file byteLength is required')\n\n  // fetch last bytes (footer) of the file\n  const footerOffset = Math.max(0, asyncBuffer.byteLength - initialFetchSize)\n  const footerBuffer = await asyncBuffer.slice(footerOffset, asyncBuffer.byteLength)\n\n  // Check for parquet magic number \"PAR1\"\n  const footerView = new DataView(footerBuffer)\n  if (footerView.getUint32(footerBuffer.byteLength - 4, true) !== 0x31524150) {\n    throw new Error('parquet file invalid (footer != PAR1)')\n  }\n\n  // Parquet files store metadata at the end of the file\n  // Metadata length is 4 bytes before the last PAR1\n  const metadataLength = footerView.getUint32(footerBuffer.byteLength - 8, true)\n  if (metadataLength > asyncBuffer.byteLength - 8) {\n    throw new Error(`parquet metadata length ${metadataLength} exceeds available buffer ${asyncBuffer.byteLength - 8}`)\n  }\n\n  // check if metadata size fits inside the initial fetch\n  if (metadataLength + 8 > initialFetchSize) {\n    // fetch the rest of the metadata\n    const metadataOffset = asyncBuffer.byteLength - metadataLength - 8\n    const metadataBuffer = await asyncBuffer.slice(metadataOffset, footerOffset)\n    // combine initial fetch with the new slice\n    const combinedBuffer = new ArrayBuffer(metadataLength + 8)\n    const combinedView = new Uint8Array(combinedBuffer)\n    combinedView.set(new Uint8Array(metadataBuffer))\n    combinedView.set(new Uint8Array(footerBuffer), footerOffset - metadataOffset)\n    return parquetMetadata(combinedBuffer)\n  } else {\n    // parse metadata from the footer\n    return parquetMetadata(footerBuffer)\n  }\n}\n\n/**\n * Read parquet metadata from a buffer synchronously.\n *\n * @param {ArrayBuffer} arrayBuffer parquet file contents\n * @returns {FileMetaData} parquet metadata object\n */\nexport function parquetMetadata(arrayBuffer) {\n  if (!arrayBuffer) throw new Error('parquet file is required')\n  const view = new DataView(arrayBuffer)\n\n  // Validate footer magic number \"PAR1\"\n  if (view.byteLength < 8) {\n    throw new Error('parquet file is too short')\n  }\n  if (view.getUint32(view.byteLength - 4, true) !== 0x31524150) {\n    throw new Error('parquet file invalid (footer != PAR1)')\n  }\n\n  // Parquet files store metadata at the end of the file\n  // Metadata length is 4 bytes before the last PAR1\n  const metadataLengthOffset = view.byteLength - 8\n  const metadataLength = view.getUint32(metadataLengthOffset, true)\n  if (metadataLength > view.byteLength - 8) {\n    // {metadata}, metadata_length, PAR1\n    throw new Error(`parquet metadata length ${metadataLength} exceeds available buffer ${view.byteLength - 8}`)\n  }\n\n  const metadataOffset = metadataLengthOffset - metadataLength\n  const reader = { view, offset: metadataOffset }\n  const metadata = deserializeTCompactProtocol(reader)\n  const decoder = new TextDecoder()\n  function decode(/** @type {Uint8Array} */ value) {\n    return value && decoder.decode(value)\n  }\n\n  // Parse metadata from thrift data\n  const version = metadata.field_1\n  /** @type {SchemaElement[]} */\n  const schema = metadata.field_2.map((/** @type {any} */ field) => ({\n    type: ParquetType[field.field_1],\n    type_length: field.field_2,\n    repetition_type: FieldRepetitionType[field.field_3],\n    name: decode(field.field_4),\n    num_children: field.field_5,\n    converted_type: ConvertedType[field.field_6],\n    scale: field.field_7,\n    precision: field.field_8,\n    field_id: field.field_9,\n    logical_type: logicalType(field.field_10),\n  }))\n  // schema element per column index\n  const columnSchema = schema.filter(e => e.type)\n  const num_rows = metadata.field_3\n  const row_groups = metadata.field_4.map((/** @type {any} */ rowGroup) => ({\n    columns: rowGroup.field_1.map((/** @type {any} */ column, /** @type {number} */ columnIndex) => ({\n      file_path: decode(column.field_1),\n      file_offset: column.field_2,\n      meta_data: column.field_3 && {\n        type: ParquetType[column.field_3.field_1],\n        encodings: column.field_3.field_2?.map((/** @type {number} */ e) => Encoding[e]),\n        path_in_schema: column.field_3.field_3.map(decode),\n        codec: CompressionCodec[column.field_3.field_4],\n        num_values: column.field_3.field_5,\n        total_uncompressed_size: column.field_3.field_6,\n        total_compressed_size: column.field_3.field_7,\n        key_value_metadata: column.field_3.field_8,\n        data_page_offset: column.field_3.field_9,\n        index_page_offset: column.field_3.field_10,\n        dictionary_page_offset: column.field_3.field_11,\n        statistics: convertStats(column.field_3.field_12, columnSchema[columnIndex]),\n        encoding_stats: column.field_3.field_13?.map((/** @type {any} */ encodingStat) => ({\n          page_type: PageType[encodingStat.field_1],\n          encoding: Encoding[encodingStat.field_2],\n          count: encodingStat.field_3,\n        })),\n        bloom_filter_offset: column.field_3.field_14,\n        bloom_filter_length: column.field_3.field_15,\n        size_statistics: column.field_3.field_16 && {\n          unencoded_byte_array_data_bytes: column.field_3.field_16.field_1,\n          repetition_level_histogram: column.field_3.field_16.field_2,\n          definition_level_histogram: column.field_3.field_16.field_3,\n        },\n      },\n      offset_index_offset: column.field_4,\n      offset_index_length: column.field_5,\n      column_index_offset: column.field_6,\n      column_index_length: column.field_7,\n      crypto_metadata: column.field_7,\n      encrypted_column_metadata: column.field_8,\n    })),\n    total_byte_size: rowGroup.field_2,\n    num_rows: rowGroup.field_3,\n    sorting_columns: rowGroup.field_4?.map((/** @type {any} */ sortingColumn) => ({\n      column_idx: sortingColumn.field_1,\n      descending: sortingColumn.field_2,\n      nulls_first: sortingColumn.field_3,\n    })),\n    file_offset: rowGroup.field_5,\n    total_compressed_size: rowGroup.field_6,\n    ordinal: rowGroup.field_7,\n  }))\n  const key_value_metadata = metadata.field_5?.map((/** @type {any} */ keyValue) => ({\n    key: decode(keyValue.field_1),\n    value: decode(keyValue.field_2),\n  }))\n  const created_by = decode(metadata.field_6)\n\n  return {\n    version,\n    schema,\n    num_rows,\n    row_groups,\n    key_value_metadata,\n    created_by,\n    metadata_length: metadataLength,\n  }\n}\n\n/**\n * Return a tree of schema elements from parquet metadata.\n *\n * @param {FileMetaData} metadata parquet metadata object\n * @returns {import(\"./types.d.ts\").SchemaTree} tree of schema elements\n */\nexport function parquetSchema(metadata) {\n  return getSchemaPath(metadata.schema, [])[0]\n}\n\n/**\n * @param {any} logicalType\n * @returns {import(\"./types.d.ts\").LogicalType | undefined}\n */\nfunction logicalType(logicalType) {\n  if (logicalType?.field_1) return { type: 'STRING' }\n  if (logicalType?.field_2) return { type: 'MAP' }\n  if (logicalType?.field_3) return { type: 'LIST' }\n  if (logicalType?.field_4) return { type: 'ENUM' }\n  if (logicalType?.field_5) return {\n    type: 'DECIMAL',\n    scale: logicalType.field_5.field_1,\n    precision: logicalType.field_5.field_2,\n  }\n  if (logicalType?.field_6) return { type: 'DATE' }\n  if (logicalType?.field_7) return {\n    type: 'TIME',\n    isAdjustedToUTC: logicalType.field_7.field_1,\n    unit: timeUnit(logicalType.field_7.field_2),\n  }\n  if (logicalType?.field_8) return {\n    type: 'TIMESTAMP',\n    isAdjustedToUTC: logicalType.field_8.field_1,\n    unit: timeUnit(logicalType.field_8.field_2),\n  }\n  if (logicalType?.field_10) return {\n    type: 'INTEGER',\n    bitWidth: logicalType.field_10.field_1,\n    isSigned: logicalType.field_10.field_2,\n  }\n  if (logicalType?.field_11) return { type: 'NULL' }\n  if (logicalType?.field_12) return { type: 'JSON' }\n  if (logicalType?.field_13) return { type: 'BSON' }\n  if (logicalType?.field_14) return { type: 'UUID' }\n  if (logicalType?.field_15) return { type: 'FLOAT16' }\n  return logicalType\n}\n\n/**\n * @param {any} unit\n * @returns {import(\"./types.d.ts\").TimeUnit}\n */\nfunction timeUnit(unit) {\n  if (unit.field_1) return 'MILLIS'\n  if (unit.field_2) return 'MICROS'\n  if (unit.field_3) return 'NANOS'\n  throw new Error('parquet time unit required')\n}\n\n/**\n * Convert column statistics based on column type.\n *\n * @param {any} stats\n * @param {SchemaElement} schema\n * @returns {import(\"./types.d.ts\").Statistics}\n */\nfunction convertStats(stats, schema) {\n  return stats && {\n    max: convertMetadata(stats.field_1, schema),\n    min: convertMetadata(stats.field_2, schema),\n    null_count: stats.field_3,\n    distinct_count: stats.field_4,\n    max_value: convertMetadata(stats.field_5, schema),\n    min_value: convertMetadata(stats.field_6, schema),\n    is_max_value_exact: stats.field_7,\n    is_min_value_exact: stats.field_8,\n  }\n}\n\n/**\n * @param {Uint8Array | undefined} value\n * @param {SchemaElement} schema\n * @returns {import('./types.d.ts').MinMaxType | undefined}\n */\nexport function convertMetadata(value, schema) {\n  const { type, converted_type, logical_type } = schema\n  if (value === undefined) return value\n  if (type === 'BOOLEAN') return value[0] === 1\n  if (type === 'BYTE_ARRAY') return new TextDecoder().decode(value)\n  const view = new DataView(value.buffer, value.byteOffset, value.byteLength)\n  if (type === 'FLOAT' && view.byteLength === 4) return view.getFloat32(0, true)\n  if (type === 'DOUBLE' && view.byteLength === 8) return view.getFloat64(0, true)\n  if (type === 'INT32' && converted_type === 'DATE') return new Date(view.getInt32(0, true) * 86400000)\n  if (type === 'INT64' && converted_type === 'TIMESTAMP_MICROS') return new Date(Number(view.getBigInt64(0, true) / 1000n))\n  if (type === 'INT64' && converted_type === 'TIMESTAMP_MILLIS') return new Date(Number(view.getBigInt64(0, true)))\n  if (type === 'INT64' && logical_type?.type === 'TIMESTAMP') return new Date(Number(view.getBigInt64(0, true)))\n  if (type === 'INT32' && view.byteLength === 4) return view.getInt32(0, true)\n  if (type === 'INT64' && view.byteLength === 8) return view.getBigInt64(0, true)\n  if (converted_type === 'DECIMAL') return parseDecimal(value) * Math.pow(10, -(schema.scale || 0))\n  if (logical_type?.type === 'FLOAT16') return parseFloat16(value)\n  if (type === 'FIXED_LEN_BYTE_ARRAY') return value\n  // assert(false)\n  return value\n}\n","import { isListLike, isMapLike } from './schema.js'\n\n/**\n * Dremel-assembly of arrays of values into lists\n *\n * Reconstructs a complex nested structure from flat arrays of definition and repetition levels,\n * according to Dremel encoding.\n *\n * @typedef {import('./types.d.ts').DecodedArray} DecodedArray\n * @typedef {import('./types.d.ts').FieldRepetitionType} FieldRepetitionType\n * @param {any[]} output\n * @param {number[] | undefined} definitionLevels\n * @param {number[]} repetitionLevels\n * @param {DecodedArray} values\n * @param {(FieldRepetitionType | undefined)[]} repetitionPath\n * @param {number} maxDefinitionLevel definition level that corresponds to non-null\n * @returns {any[]}\n */\nexport function assembleLists(\n  output, definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel\n) {\n  const n = definitionLevels?.length || repetitionLevels.length\n  let valueIndex = 0\n\n  // Track state of nested structures\n  const containerStack = [output]\n  let currentContainer = output\n  let currentDepth = 0 // schema depth\n  let currentDefLevel = 0 // list depth\n  let currentRepLevel = 0\n\n  if (repetitionLevels[0]) {\n    // continue previous row\n    while (currentDepth < repetitionPath.length - 2 && currentRepLevel < repetitionLevels[0]) {\n      // go into last list\n      currentContainer = currentContainer.at(-1)\n      containerStack.push(currentContainer)\n      currentDepth++\n      if (repetitionPath[currentDepth] !== 'REQUIRED') currentDefLevel++\n      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel++\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    // assert(currentDefLevel === containerStack.length - 1)\n    const def = definitionLevels?.length ? definitionLevels[i] : maxDefinitionLevel\n    const rep = repetitionLevels[i]\n\n    // Pop up to start of rep level\n    while (currentDepth && (rep < currentRepLevel || repetitionPath[currentDepth] !== 'REPEATED')) {\n      if (repetitionPath[currentDepth] !== 'REQUIRED') {\n        containerStack.pop()\n        currentDefLevel--\n      }\n      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel--\n      currentDepth--\n    }\n    // @ts-expect-error won't be empty\n    currentContainer = containerStack.at(-1)\n\n    // Go deeper to end of definition level\n    while (\n      (currentDepth < repetitionPath.length - 2 || repetitionPath[currentDepth + 1] === 'REPEATED') &&\n      (currentDefLevel < def || repetitionPath[currentDepth + 1] === 'REQUIRED')\n    ) {\n      currentDepth++\n      if (repetitionPath[currentDepth] !== 'REQUIRED') {\n        /** @type {any[]} */\n        const newList = []\n        currentContainer.push(newList)\n        currentContainer = newList\n        containerStack.push(newList)\n        currentDefLevel++\n      }\n      if (repetitionPath[currentDepth] === 'REPEATED') currentRepLevel++\n    }\n\n    // Add value or null based on definition level\n    if (def === maxDefinitionLevel) {\n      // assert(currentDepth === maxDefinitionLevel || currentDepth === repetitionPath.length - 2)\n      currentContainer.push(values[valueIndex++])\n    } else if (currentDepth === repetitionPath.length - 2) {\n      currentContainer.push(null)\n    } else {\n      currentContainer.push([])\n    }\n  }\n\n  // Handle edge cases for empty inputs or single-level data\n  if (!output.length) {\n    // return max definition level of nested lists\n    for (let i = 0; i < maxDefinitionLevel; i++) {\n      /** @type {any[]} */\n      const newList = []\n      currentContainer.push(newList)\n      currentContainer = newList\n    }\n  }\n\n  return output\n}\n\n/**\n * Assemble a nested structure from subcolumn data.\n * https://github.com/apache/parquet-format/blob/apache-parquet-format-2.10.0/LogicalTypes.md#nested-types\n *\n * @typedef {import('./types.d.ts').SchemaTree} SchemaTree\n * @param {Map<string, any[]>} subcolumnData\n * @param {SchemaTree} schema top-level schema element\n * @param {number} [depth] depth of nested structure\n */\nexport function assembleNested(subcolumnData, schema, depth = 0) {\n  const path = schema.path.join('.')\n  const optional = schema.element.repetition_type === 'OPTIONAL'\n  const nextDepth = optional ? depth + 1 : depth\n\n  if (isListLike(schema)) {\n    let sublist = schema.children[0]\n    let subDepth = nextDepth\n    if (sublist.children.length === 1) {\n      sublist = sublist.children[0]\n      subDepth++\n    }\n    assembleNested(subcolumnData, sublist, subDepth)\n\n    const subcolumn = sublist.path.join('.')\n    const values = subcolumnData.get(subcolumn)\n    if (!values) throw new Error('parquet list column missing values')\n    if (optional) flattenAtDepth(values, depth)\n    subcolumnData.set(path, values)\n    subcolumnData.delete(subcolumn)\n    return\n  }\n\n  if (isMapLike(schema)) {\n    const mapName = schema.children[0].element.name\n\n    // Assemble keys and values\n    assembleNested(subcolumnData, schema.children[0].children[0], nextDepth + 1)\n    assembleNested(subcolumnData, schema.children[0].children[1], nextDepth + 1)\n\n    const keys = subcolumnData.get(`${path}.${mapName}.key`)\n    const values = subcolumnData.get(`${path}.${mapName}.value`)\n\n    if (!keys) throw new Error('parquet map column missing keys')\n    if (!values) throw new Error('parquet map column missing values')\n    if (keys.length !== values.length) {\n      throw new Error('parquet map column key/value length mismatch')\n    }\n\n    const out = assembleMaps(keys, values, nextDepth)\n    if (optional) flattenAtDepth(out, depth)\n\n    subcolumnData.delete(`${path}.${mapName}.key`)\n    subcolumnData.delete(`${path}.${mapName}.value`)\n    subcolumnData.set(path, out)\n    return\n  }\n\n  // Struct-like column\n  if (schema.children.length) {\n    // construct a meta struct and then invert\n    const invertDepth = schema.element.repetition_type === 'REQUIRED' ? depth : depth + 1\n    /** @type {Record<string, any>} */\n    const struct = {}\n    for (const child of schema.children) {\n      assembleNested(subcolumnData, child, invertDepth)\n      const childData = subcolumnData.get(child.path.join('.'))\n      if (!childData) throw new Error('parquet struct missing child data')\n      struct[child.element.name] = childData\n    }\n    // remove children\n    for (const child of schema.children) {\n      subcolumnData.delete(child.path.join('.'))\n    }\n    // invert struct by depth\n    const inverted = invertStruct(struct, invertDepth)\n    if (optional) flattenAtDepth(inverted, depth)\n    subcolumnData.set(path, inverted)\n  }\n}\n\n/**\n * @param {any[]} arr\n * @param {number} depth\n */\nfunction flattenAtDepth(arr, depth) {\n  for (let i = 0; i < arr.length; i++) {\n    if (depth) {\n      flattenAtDepth(arr[i], depth - 1)\n    } else {\n      arr[i] = arr[i][0]\n    }\n  }\n}\n\n/**\n * @param {any[]} keys\n * @param {any[]} values\n * @param {number} depth\n * @returns {any[]}\n */\nfunction assembleMaps(keys, values, depth) {\n  const out = []\n  for (let i = 0; i < keys.length; i++) {\n    if (depth) {\n      out.push(assembleMaps(keys[i], values[i], depth - 1)) // go deeper\n    } else {\n      if (keys[i]) {\n        /** @type {Record<string, any>} */\n        const obj = {}\n        for (let j = 0; j < keys[i].length; j++) {\n          const value = values[i][j]\n          obj[keys[i][j]] = value === undefined ? null : value\n        }\n        out.push(obj)\n      } else {\n        out.push(undefined)\n      }\n    }\n  }\n  return out\n}\n\n/**\n * Invert a struct-like object by depth.\n *\n * @param {Record<string, any[]>} struct\n * @param {number} depth\n * @returns {any[]}\n */\nfunction invertStruct(struct, depth) {\n  const keys = Object.keys(struct)\n  const length = struct[keys[0]]?.length\n  const out = []\n  for (let i = 0; i < length; i++) {\n    /** @type {Record<string, any>} */\n    const obj = {}\n    for (const key of keys) {\n      if (struct[key].length !== length) throw new Error('parquet struct parsing error')\n      obj[key] = struct[key][i]\n    }\n    if (depth) {\n      out.push(invertStruct(obj, depth - 1)) // deeper\n    } else {\n      out.push(obj)\n    }\n  }\n  return out\n}\n","import { readVarInt } from './thrift.js'\n\n/**\n * Minimum bits needed to store value.\n *\n * @param {number} value\n * @returns {number}\n */\nexport function bitWidth(value) {\n  return 32 - Math.clz32(value)\n}\n\n/**\n * Read values from a run-length encoded/bit-packed hybrid encoding.\n *\n * If length is zero, then read int32 length at the start.\n *\n * @typedef {import(\"./types.d.ts\").DataReader} DataReader\n * @typedef {import(\"./types.d.ts\").DecodedArray} DecodedArray\n * @param {DataReader} reader\n * @param {number} width - width of each bit-packed group\n * @param {number} length - length of the encoded data\n * @param {DecodedArray} output\n */\nexport function readRleBitPackedHybrid(reader, width, length, output) {\n  if (!length) {\n    // length = reader.view.getUint32(reader.offset, true)\n    reader.offset += 4\n  }\n  let seen = 0\n  while (seen < output.length) {\n    const header = readVarInt(reader)\n    if (header & 1) {\n      // bit-packed\n      seen = readBitPacked(reader, header, width, output, seen)\n    } else {\n      // rle\n      const count = header >>> 1\n      readRle(reader, count, width, output, seen)\n      seen += count\n    }\n  }\n  // assert(reader.offset - startOffset === length)\n}\n\n/**\n * Run-length encoding: read value with bitWidth and repeat it count times.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @param {number} bitWidth\n * @param {DecodedArray} output\n * @param {number} seen\n */\nfunction readRle(reader, count, bitWidth, output, seen) {\n  const width = bitWidth + 7 >> 3\n  let value = 0\n  for (let i = 0; i < width; i++) {\n    value |= reader.view.getUint8(reader.offset++) << (i << 3)\n  }\n  // assert(value < 1 << bitWidth)\n\n  // repeat value count times\n  for (let i = 0; i < count; i++) {\n    output[seen + i] = value\n  }\n}\n\n/**\n * Read a bit-packed run of the rle/bitpack hybrid.\n * Supports width > 8 (crossing bytes).\n *\n * @param {DataReader} reader\n * @param {number} header - bit-pack header\n * @param {number} bitWidth\n * @param {DecodedArray} output\n * @param {number} seen\n * @returns {number} total output values so far\n */\nfunction readBitPacked(reader, header, bitWidth, output, seen) {\n  let count = header >> 1 << 3 // values to read\n  const mask = (1 << bitWidth) - 1\n\n  let data = 0\n  if (reader.offset < reader.view.byteLength) {\n    data = reader.view.getUint8(reader.offset++)\n  } else if (mask) {\n    // sometimes out-of-bounds reads are masked out\n    throw new Error(`parquet bitpack offset ${reader.offset} out of range`)\n  }\n  let left = 8\n  let right = 0\n\n  // read values\n  while (count) {\n    // if we have crossed a byte boundary, shift the data\n    if (right > 8) {\n      right -= 8\n      left -= 8\n      data >>>= 8\n    } else if (left - right < bitWidth) {\n      // if we don't have bitWidth number of bits to read, read next byte\n      data |= reader.view.getUint8(reader.offset) << left\n      reader.offset++\n      left += 8\n    } else {\n      if (seen < output.length) {\n        // emit value\n        output[seen++] = data >> right & mask\n      }\n      count--\n      right += bitWidth\n    }\n  }\n\n  return seen\n}\n\n/**\n * @typedef {import(\"./types.d.ts\").ParquetType} ParquetType\n * @param {DataReader} reader\n * @param {number} count\n * @param {ParquetType} type\n * @param {number | undefined} typeLength\n * @returns {DecodedArray}\n */\nexport function byteStreamSplit(reader, count, type, typeLength) {\n  const width = byteWidth(type, typeLength)\n  const bytes = new Uint8Array(count * width)\n  for (let b = 0; b < width; b++) {\n    for (let i = 0; i < count; i++) {\n      bytes[i * width + b] = reader.view.getUint8(reader.offset++)\n    }\n  }\n  // interpret bytes as typed array\n  if (type === 'FLOAT') return new Float32Array(bytes.buffer)\n  else if (type === 'DOUBLE') return new Float64Array(bytes.buffer)\n  else if (type === 'INT32') return new Int32Array(bytes.buffer)\n  else if (type === 'INT64') return new BigInt64Array(bytes.buffer)\n  else if (type === 'FIXED_LEN_BYTE_ARRAY') {\n    // split into arrays of typeLength\n    const split = new Array(count)\n    for (let i = 0; i < count; i++) {\n      split[i] = bytes.subarray(i * width, (i + 1) * width)\n    }\n    return split\n  }\n  throw new Error(`parquet byte_stream_split unsupported type: ${type}`)\n}\n\n/**\n * @param {ParquetType} type\n * @param {number | undefined} typeLength\n * @returns {number}\n */\nfunction byteWidth(type, typeLength) {\n  switch (type) {\n  case 'INT32':\n  case 'FLOAT':\n    return 4\n  case 'INT64':\n  case 'DOUBLE':\n    return 8\n  case 'FIXED_LEN_BYTE_ARRAY':\n    if (!typeLength) throw new Error('parquet byteWidth missing type_length')\n    return typeLength\n  default:\n    throw new Error(`parquet unsupported type: ${type}`)\n  }\n}\n","/**\n * Read `count` values of the given type from the reader.view.\n *\n * @typedef {import(\"./types.d.ts\").DataReader} DataReader\n * @typedef {import(\"./types.d.ts\").DecodedArray} DecodedArray\n * @typedef {import(\"./types.d.ts\").ParquetType} ParquetType\n * @param {DataReader} reader - buffer to read data from\n * @param {ParquetType} type - parquet type of the data\n * @param {number} count - number of values to read\n * @param {number | undefined} fixedLength - length of each fixed length byte array\n * @returns {DecodedArray} array of values\n */\nexport function readPlain(reader, type, count, fixedLength) {\n  if (count === 0) return []\n  if (type === 'BOOLEAN') {\n    return readPlainBoolean(reader, count)\n  } else if (type === 'INT32') {\n    return readPlainInt32(reader, count)\n  } else if (type === 'INT64') {\n    return readPlainInt64(reader, count)\n  } else if (type === 'INT96') {\n    return readPlainInt96(reader, count)\n  } else if (type === 'FLOAT') {\n    return readPlainFloat(reader, count)\n  } else if (type === 'DOUBLE') {\n    return readPlainDouble(reader, count)\n  } else if (type === 'BYTE_ARRAY') {\n    return readPlainByteArray(reader, count)\n  } else if (type === 'FIXED_LEN_BYTE_ARRAY') {\n    if (!fixedLength) throw new Error('parquet missing fixed length')\n    return readPlainByteArrayFixed(reader, count, fixedLength)\n  } else {\n    throw new Error(`parquet unhandled type: ${type}`)\n  }\n}\n\n/**\n * Read `count` boolean values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {boolean[]}\n */\nfunction readPlainBoolean(reader, count) {\n  const values = new Array(count)\n  for (let i = 0; i < count; i++) {\n    const byteOffset = reader.offset + (i / 8 | 0)\n    const bitOffset = i % 8\n    const byte = reader.view.getUint8(byteOffset)\n    values[i] = (byte & 1 << bitOffset) !== 0\n  }\n  reader.offset += Math.ceil(count / 8)\n  return values\n}\n\n/**\n * Read `count` int32 values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {Int32Array}\n */\nfunction readPlainInt32(reader, count) {\n  const values = (reader.view.byteOffset + reader.offset) % 4\n    ? new Int32Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 4))\n    : new Int32Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)\n  reader.offset += count * 4\n  return values\n}\n\n/**\n * Read `count` int64 values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {BigInt64Array}\n */\nfunction readPlainInt64(reader, count) {\n  const values = (reader.view.byteOffset + reader.offset) % 8\n    ? new BigInt64Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 8))\n    : new BigInt64Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)\n  reader.offset += count * 8\n  return values\n}\n\n/**\n * Read `count` int96 values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {bigint[]}\n */\nfunction readPlainInt96(reader, count) {\n  const values = new Array(count)\n  for (let i = 0; i < count; i++) {\n    const low = reader.view.getBigInt64(reader.offset + i * 12, true)\n    const high = reader.view.getInt32(reader.offset + i * 12 + 8, true)\n    values[i] = BigInt(high) << 64n | low\n  }\n  reader.offset += count * 12\n  return values\n}\n\n/**\n * Read `count` float values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {Float32Array}\n */\nfunction readPlainFloat(reader, count) {\n  const values = (reader.view.byteOffset + reader.offset) % 4\n    ? new Float32Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 4))\n    : new Float32Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)\n  reader.offset += count * 4\n  return values\n}\n\n/**\n * Read `count` double values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {Float64Array}\n */\nfunction readPlainDouble(reader, count) {\n  const values = (reader.view.byteOffset + reader.offset) % 8\n    ? new Float64Array(align(reader.view.buffer, reader.view.byteOffset + reader.offset, count * 8))\n    : new Float64Array(reader.view.buffer, reader.view.byteOffset + reader.offset, count)\n  reader.offset += count * 8\n  return values\n}\n\n/**\n * Read `count` byte array values.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @returns {Uint8Array[]}\n */\nfunction readPlainByteArray(reader, count) {\n  const values = new Array(count)\n  for (let i = 0; i < count; i++) {\n    const length = reader.view.getInt32(reader.offset, true)\n    reader.offset += 4\n    values[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, length)\n    reader.offset += length\n  }\n  return values\n}\n\n/**\n * Read a fixed length byte array.\n *\n * @param {DataReader} reader\n * @param {number} count\n * @param {number} fixedLength\n * @returns {Uint8Array[]}\n */\nfunction readPlainByteArrayFixed(reader, count, fixedLength) {\n  // assert(reader.view.byteLength - reader.offset >= count * fixedLength)\n  const values = new Array(count)\n  for (let i = 0; i < count; i++) {\n    values[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, fixedLength)\n    reader.offset += fixedLength\n  }\n  return values\n}\n\n/**\n * Create a new buffer with the offset and size.\n *\n * @param {ArrayBuffer} buffer\n * @param {number} offset\n * @param {number} size\n * @returns {ArrayBuffer}\n */\nfunction align(buffer, offset, size) {\n  const aligned = new ArrayBuffer(size)\n  new Uint8Array(aligned).set(new Uint8Array(buffer, offset, size))\n  return aligned\n}\n","/**\n * The MIT License (MIT)\n * Copyright (c) 2016 Zhipeng Jia\n * https://github.com/zhipeng-jia/snappyjs\n */\n\nconst WORD_MASK = [0, 0xff, 0xffff, 0xffffff, 0xffffffff]\n\n/**\n * Copy bytes from one array to another\n *\n * @param {Uint8Array} fromArray source array\n * @param {number} fromPos source position\n * @param {Uint8Array} toArray destination array\n * @param {number} toPos destination position\n * @param {number} length number of bytes to copy\n * @returns {void}\n */\nfunction copyBytes(fromArray, fromPos, toArray, toPos, length) {\n  for (let i = 0; i < length; i++) {\n    toArray[toPos + i] = fromArray[fromPos + i]\n  }\n}\n\n/**\n * Copy bytes within an array\n *\n * @param {Uint8Array} array source and destination array\n * @param {number} pos source position\n * @param {number} offset offset back from current position to read\n * @param {number} length number of bytes to copy\n * @returns {void}\n */\nfunction selfCopyBytes(array, pos, offset, length) {\n  for (let i = 0; i < length; i++) {\n    array[pos + i] = array[pos - offset + i]\n  }\n}\n\n/**\n * Decompress snappy data.\n * Accepts an output buffer to avoid allocating a new buffer for each call.\n *\n * @param {Uint8Array} input compressed data\n * @param {Uint8Array} output output buffer\n * @returns {void}\n */\nexport function snappyUncompress(input, output) {\n  const inputLength = input.byteLength\n  const outputLength = output.byteLength\n  let pos = 0\n  let outPos = 0\n\n  // skip preamble (contains uncompressed length as varint)\n  while (pos < inputLength) {\n    const c = input[pos]\n    pos++\n    if (c < 128) {\n      break\n    }\n  }\n  if (outputLength && pos >= inputLength) {\n    throw new Error('invalid snappy length header')\n  }\n\n  while (pos < inputLength) {\n    const c = input[pos]\n    let len = 0\n    pos++\n\n    if (pos >= inputLength) {\n      throw new Error('missing eof marker')\n    }\n\n    // There are two types of elements, literals and copies (back references)\n    if ((c & 0x3) === 0) {\n      // Literals are uncompressed data stored directly in the byte stream\n      let len = (c >>> 2) + 1\n      // Longer literal length is encoded in multiple bytes\n      if (len > 60) {\n        if (pos + 3 >= inputLength) {\n          throw new Error('snappy error literal pos + 3 >= inputLength')\n        }\n        const lengthSize = len - 60 // length bytes - 1\n        len = input[pos]\n          + (input[pos + 1] << 8)\n          + (input[pos + 2] << 16)\n          + (input[pos + 3] << 24)\n        len = (len & WORD_MASK[lengthSize]) + 1\n        pos += lengthSize\n      }\n      if (pos + len > inputLength) {\n        throw new Error('snappy error literal exceeds input length')\n      }\n      copyBytes(input, pos, output, outPos, len)\n      pos += len\n      outPos += len\n    } else {\n      // Copy elements\n      let offset = 0 // offset back from current position to read\n      switch (c & 0x3) {\n      case 1:\n        // Copy with 1-byte offset\n        len = (c >>> 2 & 0x7) + 4\n        offset = input[pos] + (c >>> 5 << 8)\n        pos++\n        break\n      case 2:\n        // Copy with 2-byte offset\n        if (inputLength <= pos + 1) {\n          throw new Error('snappy error end of input')\n        }\n        len = (c >>> 2) + 1\n        offset = input[pos] + (input[pos + 1] << 8)\n        pos += 2\n        break\n      case 3:\n        // Copy with 4-byte offset\n        if (inputLength <= pos + 3) {\n          throw new Error('snappy error end of input')\n        }\n        len = (c >>> 2) + 1\n        offset = input[pos]\n          + (input[pos + 1] << 8)\n          + (input[pos + 2] << 16)\n          + (input[pos + 3] << 24)\n        pos += 4\n        break\n      default:\n        break\n      }\n      if (offset === 0 || isNaN(offset)) {\n        throw new Error(`invalid offset ${offset} pos ${pos} inputLength ${inputLength}`)\n      }\n      if (offset > outPos) {\n        throw new Error('cannot copy from before start of buffer')\n      }\n      selfCopyBytes(output, outPos, offset, len)\n      outPos += len\n    }\n  }\n\n  if (outPos !== outputLength) throw new Error('premature end of input')\n}\n","import { bitWidth, byteStreamSplit, readRleBitPackedHybrid } from './encoding.js'\nimport { readPlain } from './plain.js'\nimport { getMaxDefinitionLevel, getMaxRepetitionLevel } from './schema.js'\nimport { snappyUncompress } from './snappy.js'\n\n/**\n * Read a data page from uncompressed reader.\n *\n * @typedef {import(\"./types.d.ts\").DataPage} DataPage\n * @typedef {import(\"./types.d.ts\").ColumnMetaData} ColumnMetaData\n * @typedef {import(\"./types.d.ts\").DataPageHeader} DataPageHeader\n * @typedef {import(\"./types.d.ts\").SchemaTree} SchemaTree\n * @typedef {import(\"./types.d.ts\").DecodedArray} DecodedArray\n * @param {Uint8Array} bytes raw page data (should already be decompressed)\n * @param {DataPageHeader} daph data page header\n * @param {SchemaTree[]} schemaPath\n * @param {ColumnMetaData} columnMetadata\n * @returns {DataPage} definition levels, repetition levels, and array of values\n */\nexport function readDataPage(bytes, daph, schemaPath, { type }) {\n  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  const reader = { view, offset: 0 }\n  /** @type {DecodedArray} */\n  let dataPage\n\n  // repetition and definition levels\n  const repetitionLevels = readRepetitionLevels(reader, daph, schemaPath)\n  // assert(!repetitionLevels.length || repetitionLevels.length === daph.num_values)\n  const { definitionLevels, numNulls } = readDefinitionLevels(reader, daph, schemaPath)\n  // assert(!definitionLevels.length || definitionLevels.length === daph.num_values)\n\n  // read values based on encoding\n  const nValues = daph.num_values - numNulls\n  if (daph.encoding === 'PLAIN') {\n    const { type_length } = schemaPath[schemaPath.length - 1].element\n    dataPage = readPlain(reader, type, nValues, type_length)\n  } else if (\n    daph.encoding === 'PLAIN_DICTIONARY' ||\n    daph.encoding === 'RLE_DICTIONARY' ||\n    daph.encoding === 'RLE'\n  ) {\n    const bitWidth = type === 'BOOLEAN' ? 1 : view.getUint8(reader.offset++)\n    if (bitWidth) {\n      dataPage = new Array(nValues)\n      readRleBitPackedHybrid(reader, bitWidth, view.byteLength - reader.offset, dataPage)\n    } else {\n      dataPage = new Uint8Array(nValues) // nValue zeroes\n    }\n  } else if (daph.encoding === 'BYTE_STREAM_SPLIT') {\n    const { type_length } = schemaPath[schemaPath.length - 1].element\n    dataPage = byteStreamSplit(reader, nValues, type, type_length)\n  } else {\n    throw new Error(`parquet unsupported encoding: ${daph.encoding}`)\n  }\n\n  return { definitionLevels, repetitionLevels, dataPage }\n}\n\n/**\n * @param {Uint8Array} bytes raw page data\n * @param {import(\"./types.d.ts\").DictionaryPageHeader} diph dictionary page header\n * @param {ColumnMetaData} columnMetadata\n * @param {number | undefined} typeLength - type_length from schema\n * @returns {DecodedArray}\n */\nexport function readDictionaryPage(bytes, diph, columnMetadata, typeLength) {\n  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  const reader = { view, offset: 0 }\n  return readPlain(reader, columnMetadata.type, diph.num_values, typeLength)\n}\n\n/**\n * @typedef {import(\"./types.d.ts\").DataReader} DataReader\n * @param {DataReader} reader data view for the page\n * @param {DataPageHeader} daph data page header\n * @param {SchemaTree[]} schemaPath\n * @returns {any[]} repetition levels and number of bytes read\n */\nfunction readRepetitionLevels(reader, daph, schemaPath) {\n  if (schemaPath.length > 1) {\n    const maxRepetitionLevel = getMaxRepetitionLevel(schemaPath)\n    if (maxRepetitionLevel) {\n      const values = new Array(daph.num_values)\n      readRleBitPackedHybrid(reader, bitWidth(maxRepetitionLevel), 0, values)\n      return values\n    }\n  }\n  return []\n}\n\n/**\n * @param {DataReader} reader data view for the page\n * @param {DataPageHeader} daph data page header\n * @param {SchemaTree[]} schemaPath\n * @returns {{ definitionLevels: number[], numNulls: number }} definition levels\n */\nfunction readDefinitionLevels(reader, daph, schemaPath) {\n  const maxDefinitionLevel = getMaxDefinitionLevel(schemaPath)\n  if (!maxDefinitionLevel) return { definitionLevels: [], numNulls: 0 }\n\n  const definitionLevels = new Array(daph.num_values)\n  readRleBitPackedHybrid(reader, bitWidth(maxDefinitionLevel), 0, definitionLevels)\n\n  // count nulls\n  let numNulls = daph.num_values\n  for (const def of definitionLevels) {\n    if (def === maxDefinitionLevel) numNulls--\n  }\n  if (numNulls === 0) definitionLevels.length = 0\n\n  return { definitionLevels, numNulls }\n}\n\n/**\n * @param {Uint8Array} compressedBytes\n * @param {number} uncompressed_page_size\n * @param {import('./types.js').CompressionCodec} codec\n * @param {import('./types.js').Compressors | undefined} compressors\n * @returns {Uint8Array}\n */\nexport function decompressPage(compressedBytes, uncompressed_page_size, codec, compressors) {\n  /** @type {Uint8Array} */\n  let page\n  const customDecompressor = compressors?.[codec]\n  if (codec === 'UNCOMPRESSED') {\n    page = compressedBytes\n  } else if (customDecompressor) {\n    page = customDecompressor(compressedBytes, uncompressed_page_size)\n  } else if (codec === 'SNAPPY') {\n    page = new Uint8Array(uncompressed_page_size)\n    snappyUncompress(compressedBytes, page)\n  } else {\n    throw new Error(`parquet unsupported compression codec: ${codec}`)\n  }\n  if (page?.length !== uncompressed_page_size) {\n    throw new Error(`parquet decompressed page length ${page?.length} does not match header ${uncompressed_page_size}`)\n  }\n  return page\n}\n","import { readVarInt, readZigZagBigInt } from './thrift.js'\n\n/**\n * @typedef {import('./types.d.ts').DataReader} DataReader\n * @param {DataReader} reader\n * @param {number} count number of values to read\n * @param {Int32Array | BigInt64Array} output\n */\nexport function deltaBinaryUnpack(reader, count, output) {\n  const int32 = output instanceof Int32Array\n  const blockSize = readVarInt(reader)\n  const miniblockPerBlock = readVarInt(reader)\n  readVarInt(reader) // assert(=== count)\n  let value = readZigZagBigInt(reader) // first value\n  let outputIndex = 0\n  output[outputIndex++] = int32 ? Number(value) : value\n\n  const valuesPerMiniblock = blockSize / miniblockPerBlock\n\n  while (outputIndex < count) {\n    // new block\n    const minDelta = readZigZagBigInt(reader)\n    const bitWidths = new Uint8Array(miniblockPerBlock)\n    for (let i = 0; i < miniblockPerBlock; i++) {\n      bitWidths[i] = reader.view.getUint8(reader.offset++)\n    }\n\n    for (let i = 0; i < miniblockPerBlock && outputIndex < count; i++) {\n      // new miniblock\n      const bitWidth = BigInt(bitWidths[i])\n      if (bitWidth) {\n        let bitpackPos = 0n\n        let miniblockCount = valuesPerMiniblock\n        const mask = (1n << bitWidth) - 1n\n        while (miniblockCount && outputIndex < count) {\n          let bits = BigInt(reader.view.getUint8(reader.offset)) >> bitpackPos & mask // TODO: don't re-read value every time\n          bitpackPos += bitWidth\n          while (bitpackPos >= 8) {\n            bitpackPos -= 8n\n            reader.offset++\n            if (bitpackPos) {\n              bits |= BigInt(reader.view.getUint8(reader.offset)) << bitWidth - bitpackPos & mask\n            }\n          }\n          const delta = minDelta + bits\n          value += delta\n          output[outputIndex++] = int32 ? Number(value) : value\n          miniblockCount--\n        }\n        if (miniblockCount) {\n          // consume leftover miniblock\n          reader.offset += Math.ceil((miniblockCount * Number(bitWidth) + Number(bitpackPos)) / 8)\n        }\n      } else {\n        for (let j = 0; j < valuesPerMiniblock && outputIndex < count; j++) {\n          value += minDelta\n          output[outputIndex++] = int32 ? Number(value) : value\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {DataReader} reader\n * @param {number} count\n * @param {Uint8Array[]} output\n */\nexport function deltaLengthByteArray(reader, count, output) {\n  const lengths = new Int32Array(count)\n  deltaBinaryUnpack(reader, count, lengths)\n  for (let i = 0; i < count; i++) {\n    output[i] = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, lengths[i])\n    reader.offset += lengths[i]\n  }\n}\n\n/**\n * @param {DataReader} reader\n * @param {number} count\n * @param {Uint8Array[]} output\n */\nexport function deltaByteArray(reader, count, output) {\n  const prefixData = new Int32Array(count)\n  deltaBinaryUnpack(reader, count, prefixData)\n  const suffixData = new Int32Array(count)\n  deltaBinaryUnpack(reader, count, suffixData)\n\n  for (let i = 0; i < count; i++) {\n    const suffix = new Uint8Array(reader.view.buffer, reader.view.byteOffset + reader.offset, suffixData[i])\n    if (prefixData[i]) {\n      // copy from previous value\n      output[i] = new Uint8Array(prefixData[i] + suffixData[i])\n      output[i].set(output[i - 1].subarray(0, prefixData[i]))\n      output[i].set(suffix, prefixData[i])\n    } else {\n      output[i] = suffix\n    }\n    reader.offset += suffixData[i]\n  }\n}\n","import { decompressPage } from './datapage.js'\nimport { deltaBinaryUnpack, deltaByteArray, deltaLengthByteArray } from './delta.js'\nimport { bitWidth, byteStreamSplit, readRleBitPackedHybrid } from './encoding.js'\nimport { readPlain } from './plain.js'\nimport { getMaxDefinitionLevel, getMaxRepetitionLevel } from './schema.js'\n\n/**\n * Read a data page from the given Uint8Array.\n *\n * @typedef {import(\"./types.d.ts\").DataPage} DataPage\n * @typedef {import(\"./types.d.ts\").ColumnMetaData} ColumnMetaData\n * @typedef {import(\"./types.d.ts\").Compressors} Compressors\n * @typedef {import(\"./types.d.ts\").DataPageHeaderV2} DataPageHeaderV2\n * @typedef {import(\"./types.d.ts\").SchemaTree} SchemaTree\n * @param {Uint8Array} compressedBytes raw page data\n * @param {import(\"./types.d.ts\").PageHeader} ph page header\n * @param {SchemaTree[]} schemaPath\n * @param {ColumnMetaData} columnMetadata\n * @param {Compressors | undefined} compressors\n * @returns {DataPage} definition levels, repetition levels, and array of values\n */\nexport function readDataPageV2(compressedBytes, ph, schemaPath, columnMetadata, compressors) {\n  const view = new DataView(compressedBytes.buffer, compressedBytes.byteOffset, compressedBytes.byteLength)\n  const reader = { view, offset: 0 }\n  const { codec, type } = columnMetadata\n  const daph2 = ph.data_page_header_v2\n  if (!daph2) throw new Error('parquet data page header v2 is undefined')\n\n  // repetition levels\n  const repetitionLevels = readRepetitionLevelsV2(reader, daph2, schemaPath)\n  reader.offset = daph2.repetition_levels_byte_length // readVarInt() => len for boolean v2?\n\n  // definition levels\n  const definitionLevels = readDefinitionLevelsV2(reader, daph2, schemaPath)\n  // assert(reader.offset === daph2.repetition_levels_byte_length + daph2.definition_levels_byte_length)\n\n  const uncompressedPageSize = ph.uncompressed_page_size - daph2.definition_levels_byte_length - daph2.repetition_levels_byte_length\n\n  let page = compressedBytes.subarray(reader.offset)\n  if (daph2.is_compressed !== false) {\n    page = decompressPage(page, uncompressedPageSize, codec, compressors)\n  }\n  const pageView = new DataView(page.buffer, page.byteOffset, page.byteLength)\n  const pageReader = { view: pageView, offset: 0 }\n\n  // read values based on encoding\n  /** @type {import('./types.d.ts').DecodedArray} */\n  let dataPage\n  const nValues = daph2.num_values - daph2.num_nulls\n  if (daph2.encoding === 'PLAIN') {\n    const { type_length } = schemaPath[schemaPath.length - 1].element\n    dataPage = readPlain(pageReader, type, nValues, type_length)\n  } else if (daph2.encoding === 'RLE') {\n    // assert(columnMetadata.type === 'BOOLEAN')\n    dataPage = new Array(nValues)\n    readRleBitPackedHybrid(pageReader, 1, 0, dataPage)\n    dataPage = dataPage.map(x => !!x)\n  } else if (\n    daph2.encoding === 'PLAIN_DICTIONARY' ||\n    daph2.encoding === 'RLE_DICTIONARY'\n  ) {\n    const bitWidth = pageView.getUint8(pageReader.offset++)\n    dataPage = new Array(nValues)\n    readRleBitPackedHybrid(pageReader, bitWidth, uncompressedPageSize - 1, dataPage)\n  } else if (daph2.encoding === 'DELTA_BINARY_PACKED') {\n    const int32 = type === 'INT32'\n    dataPage = int32 ? new Int32Array(nValues) : new BigInt64Array(nValues)\n    deltaBinaryUnpack(pageReader, nValues, dataPage)\n  } else if (daph2.encoding === 'DELTA_LENGTH_BYTE_ARRAY') {\n    dataPage = new Array(nValues)\n    deltaLengthByteArray(pageReader, nValues, dataPage)\n  } else if (daph2.encoding === 'DELTA_BYTE_ARRAY') {\n    dataPage = new Array(nValues)\n    deltaByteArray(pageReader, nValues, dataPage)\n  } else if (daph2.encoding === 'BYTE_STREAM_SPLIT') {\n    const { type_length } = schemaPath[schemaPath.length - 1].element\n    dataPage = byteStreamSplit(reader, nValues, type, type_length)\n  } else {\n    throw new Error(`parquet unsupported encoding: ${daph2.encoding}`)\n  }\n\n  return { definitionLevels, repetitionLevels, dataPage }\n}\n\n/**\n * @typedef {import(\"./types.d.ts\").DataReader} DataReader\n * @param {DataReader} reader\n * @param {DataPageHeaderV2} daph2 data page header v2\n * @param {SchemaTree[]} schemaPath\n * @returns {any[]} repetition levels\n */\nexport function readRepetitionLevelsV2(reader, daph2, schemaPath) {\n  const maxRepetitionLevel = getMaxRepetitionLevel(schemaPath)\n  if (!maxRepetitionLevel) return []\n\n  const values = new Array(daph2.num_values)\n  readRleBitPackedHybrid(\n    reader, bitWidth(maxRepetitionLevel), daph2.repetition_levels_byte_length, values\n  )\n  return values\n}\n\n/**\n * @param {DataReader} reader\n * @param {DataPageHeaderV2} daph2 data page header v2\n * @param {SchemaTree[]} schemaPath\n * @returns {number[] | undefined} definition levels\n */\nfunction readDefinitionLevelsV2(reader, daph2, schemaPath) {\n  const maxDefinitionLevel = getMaxDefinitionLevel(schemaPath)\n  if (maxDefinitionLevel) {\n    // V2 we know the length\n    const values = new Array(daph2.num_values)\n    readRleBitPackedHybrid(reader, bitWidth(maxDefinitionLevel), daph2.definition_levels_byte_length, values)\n    return values\n  }\n}\n","import { Encoding, PageType } from './constants.js'\nimport { deserializeTCompactProtocol } from './thrift.js'\n\n/**\n * Read parquet header from a buffer.\n *\n * @typedef {import(\"./types.d.ts\").DataReader} DataReader\n * @typedef {import(\"./types.d.ts\").PageHeader} PageHeader\n * @param {DataReader} reader - parquet file reader\n * @returns {PageHeader} metadata object and bytes read\n */\nexport function parquetHeader(reader) {\n  const header = deserializeTCompactProtocol(reader)\n\n  // Parse parquet header from thrift data\n  const type = PageType[header.field_1]\n  const uncompressed_page_size = header.field_2\n  const compressed_page_size = header.field_3\n  const crc = header.field_4\n  const data_page_header = header.field_5 && {\n    num_values: header.field_5.field_1,\n    encoding: Encoding[header.field_5.field_2],\n    definition_level_encoding: Encoding[header.field_5.field_3],\n    repetition_level_encoding: Encoding[header.field_5.field_4],\n    statistics: header.field_5.field_5 && {\n      max: header.field_5.field_5.field_1,\n      min: header.field_5.field_5.field_2,\n      null_count: header.field_5.field_5.field_3,\n      distinct_count: header.field_5.field_5.field_4,\n      max_value: header.field_5.field_5.field_5,\n      min_value: header.field_5.field_5.field_6,\n    },\n  }\n  const index_page_header = header.field_6\n  const dictionary_page_header = header.field_7 && {\n    num_values: header.field_7.field_1,\n    encoding: Encoding[header.field_7.field_2],\n    is_sorted: header.field_7.field_3,\n  }\n  const data_page_header_v2 = header.field_8 && {\n    num_values: header.field_8.field_1,\n    num_nulls: header.field_8.field_2,\n    num_rows: header.field_8.field_3,\n    encoding: Encoding[header.field_8.field_4],\n    definition_levels_byte_length: header.field_8.field_5,\n    repetition_levels_byte_length: header.field_8.field_6,\n    is_compressed: header.field_8.field_7 === undefined ? true : header.field_8.field_7, // default true\n    statistics: header.field_8.field_8,\n  }\n\n  return {\n    type,\n    uncompressed_page_size,\n    compressed_page_size,\n    crc,\n    data_page_header,\n    index_page_header,\n    dictionary_page_header,\n    data_page_header_v2,\n  }\n}\n","/**\n * Replace bigint, date, etc with legal JSON types.\n *\n * @param {any} obj object to convert\n * @returns {unknown} converted object\n */\nexport function toJson(obj) {\n  if (obj === undefined) return null\n  if (typeof obj === 'bigint') return Number(obj)\n  if (Array.isArray(obj)) return obj.map(toJson)\n  if (obj instanceof Uint8Array) return Array.from(obj)\n  if (obj instanceof Date) return obj.toISOString()\n  if (obj instanceof Object) {\n    /** @type {Record<string, unknown>} */\n    const newObj = {}\n    for (const key of Object.keys(obj)) {\n      if (obj[key] === undefined) continue\n      newObj[key] = toJson(obj[key])\n    }\n    return newObj\n  }\n  return obj\n}\n\n/**\n * Concatenate two arrays fast.\n *\n * @typedef {import('./types.js').DecodedArray} DecodedArray\n * @param {any[]} aaa first array\n * @param {DecodedArray} bbb second array\n */\nexport function concat(aaa, bbb) {\n  const chunk = 10000\n  for (let i = 0; i < bbb.length; i += chunk) {\n    aaa.push(...bbb.slice(i, i + chunk))\n  }\n}\n\n/**\n * Get the byte length of a URL using a HEAD request.\n *\n * @param {string} url\n * @returns {Promise<number>}\n */\nexport async function byteLengthFromUrl(url) {\n  return await fetch(url, { method: 'HEAD' })\n    .then(res => {\n      if (!res.ok) throw new Error(`fetch head failed ${res.status}`)\n      const length = res.headers.get('Content-Length')\n      if (!length) throw new Error('missing content length')\n      return parseInt(length)\n    })\n}\n\n/**\n * Construct an AsyncBuffer for a URL.\n *\n * @typedef {import('./types.js').AsyncBuffer} AsyncBuffer\n * @param {string} url\n * @param {number} [byteLength]\n * @returns {Promise<AsyncBuffer>}\n */\nexport async function asyncBufferFromUrl(url, byteLength) {\n  // byte length from HEAD request\n  byteLength ||= await byteLengthFromUrl(url)\n  return {\n    byteLength,\n    async slice(start, end) {\n      // fetch byte range from url\n      const headers = new Headers()\n      const endStr = end === undefined ? '' : end - 1\n      headers.set('Range', `bytes=${start}-${endStr}`)\n      const res = await fetch(url, { headers })\n      if (!res.ok || !res.body) throw new Error(`fetch failed ${res.status}`)\n      return res.arrayBuffer()\n    },\n  }\n}\n\n/**\n * Construct an AsyncBuffer for a local file using node fs package.\n *\n * @param {string} filename\n * @returns {Promise<AsyncBuffer>}\n */\nexport async function asyncBufferFromFile(filename) {\n  const fsPackage = 'fs' // webpack no include\n  const fs = await import(fsPackage)\n  const stat = await fs.promises.stat(filename)\n  return {\n    byteLength: stat.size,\n    async slice(start, end) {\n      // read file slice\n      const readStream = fs.createReadStream(filename, { start, end })\n      return await readStreamToArrayBuffer(readStream)\n    },\n  }\n}\n\n/**\n * Convert a node ReadStream to ArrayBuffer.\n *\n * @param {import('stream').Readable} input\n * @returns {Promise<ArrayBuffer>}\n */\nfunction readStreamToArrayBuffer(input) {\n  return new Promise((resolve, reject) => {\n    /** @type {Buffer[]} */\n    const chunks = []\n    input.on('data', chunk => chunks.push(chunk))\n    input.on('end', () => {\n      const buffer = Buffer.concat(chunks)\n      resolve(buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength))\n    })\n    input.on('error', reject)\n  })\n}\n","import { assembleLists } from './assemble.js'\nimport { convertWithDictionary } from './convert.js'\nimport { decompressPage, readDataPage, readDictionaryPage } from './datapage.js'\nimport { readDataPageV2 } from './datapageV2.js'\nimport { parquetHeader } from './header.js'\nimport { getMaxDefinitionLevel } from './schema.js'\nimport { concat } from './utils.js'\n\n/**\n * Parse column data from a buffer.\n *\n * @typedef {import('./types.js').ColumnMetaData} ColumnMetaData\n * @typedef {import('./types.js').DecodedArray} DecodedArray\n * @param {import('./types.js').DataReader} reader\n * @param {number} rowLimit maximum number of rows to read\n * @param {ColumnMetaData} columnMetadata column metadata\n * @param {import('./types.js').SchemaTree[]} schemaPath schema path for the column\n * @param {import('./hyparquet.js').ParquetReadOptions} options read options\n * @returns {any[]} array of values\n */\nexport function readColumn(reader, rowLimit, columnMetadata, schemaPath, { compressors, utf8 }) {\n  const { element } = schemaPath[schemaPath.length - 1]\n  /** @type {DecodedArray | undefined} */\n  let dictionary = undefined\n  /** @type {any[]} */\n  const rowData = []\n\n  while (rowData.length < rowLimit) {\n    // parse column header\n    const header = parquetHeader(reader)\n    // assert(header.compressed_page_size !== undefined)\n\n    // read compressed_page_size bytes starting at offset\n    const compressedBytes = new Uint8Array(\n      reader.view.buffer, reader.view.byteOffset + reader.offset, header.compressed_page_size\n    )\n\n    // parse page data by type\n    /** @type {DecodedArray} */\n    let values\n    if (header.type === 'DATA_PAGE') {\n      const daph = header.data_page_header\n      if (!daph) throw new Error('parquet data page header is undefined')\n\n      const page = decompressPage(compressedBytes, Number(header.uncompressed_page_size), columnMetadata.codec, compressors)\n      const { definitionLevels, repetitionLevels, dataPage } = readDataPage(page, daph, schemaPath, columnMetadata)\n      // assert(!daph.statistics?.null_count || daph.statistics.null_count === BigInt(daph.num_values - dataPage.length))\n\n      // convert types, dereference dictionary, and assemble lists\n      values = convertWithDictionary(dataPage, dictionary, element, daph.encoding, utf8)\n      if (repetitionLevels.length || definitionLevels?.length) {\n        const maxDefinitionLevel = getMaxDefinitionLevel(schemaPath)\n        const repetitionPath = schemaPath.map(({ element }) => element.repetition_type)\n        assembleLists(\n          rowData, definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel\n        )\n      } else {\n        // wrap nested flat data by depth\n        for (let i = 2; i < schemaPath.length; i++) {\n          if (schemaPath[i].element.repetition_type !== 'REQUIRED') {\n            values = Array.from(values, e => [e])\n          }\n        }\n        concat(rowData, values)\n      }\n    } else if (header.type === 'DATA_PAGE_V2') {\n      const daph2 = header.data_page_header_v2\n      if (!daph2) throw new Error('parquet data page header v2 is undefined')\n\n      const { definitionLevels, repetitionLevels, dataPage } = readDataPageV2(\n        compressedBytes, header, schemaPath, columnMetadata, compressors\n      )\n\n      // convert types, dereference dictionary, and assemble lists\n      values = convertWithDictionary(dataPage, dictionary, element, daph2.encoding, utf8)\n      if (repetitionLevels.length || definitionLevels?.length) {\n        const maxDefinitionLevel = getMaxDefinitionLevel(schemaPath)\n        const repetitionPath = schemaPath.map(({ element }) => element.repetition_type)\n        assembleLists(\n          rowData, definitionLevels, repetitionLevels, values, repetitionPath, maxDefinitionLevel\n        )\n      } else {\n        concat(rowData, values)\n      }\n    } else if (header.type === 'DICTIONARY_PAGE') {\n      const diph = header.dictionary_page_header\n      if (!diph) throw new Error('parquet dictionary page header is undefined')\n\n      const page = decompressPage(\n        compressedBytes, Number(header.uncompressed_page_size), columnMetadata.codec, compressors\n      )\n      dictionary = readDictionaryPage(page, diph, columnMetadata, element.type_length)\n    } else {\n      throw new Error(`parquet unsupported page type: ${header.type}`)\n    }\n    reader.offset += header.compressed_page_size\n  }\n  if (rowData.length < rowLimit) {\n    throw new Error(`parquet row data length ${rowData.length} does not match row group limit ${rowLimit}}`)\n  }\n  if (rowData.length > rowLimit) {\n    rowData.length = rowLimit // truncate to row limit\n  }\n  return rowData\n}\n\n/**\n * Find the start byte offset for a column chunk.\n *\n * @param {ColumnMetaData} columnMetadata\n * @returns {[bigint, bigint]} byte offset range\n */\nexport function getColumnRange({ dictionary_page_offset, data_page_offset, total_compressed_size }) {\n  let columnOffset = dictionary_page_offset\n  if (!columnOffset || data_page_offset < columnOffset) {\n    columnOffset = data_page_offset\n  }\n  return [columnOffset, columnOffset + total_compressed_size]\n}\n","import { assembleNested } from './assemble.js'\nimport { getColumnRange, readColumn } from './column.js'\nimport { parquetMetadataAsync } from './metadata.js'\nimport { getSchemaPath } from './schema.js'\nimport { concat } from './utils.js'\n\n/**\n * Read parquet data rows from a file-like object.\n * Reads the minimal number of row groups and columns to satisfy the request.\n *\n * Returns a void promise when complete, and to throw errors.\n * Data is returned in onComplete, not the return promise, because\n * if onComplete is undefined, we parse the data, and emit chunks, but skip\n * computing the row view directly. This saves on allocation if the caller\n * wants to cache the full chunks, and make their own view of the data from\n * the chunks.\n *\n * @typedef {import('./hyparquet.js').ColumnData} ColumnData\n * @typedef {import('./types.js').Compressors} Compressors\n * @typedef {import('./types.js').AsyncBuffer} AsyncBuffer\n * @typedef {import('./types.js').FileMetaData} FileMetaData\n * @param {object} options read options\n * @param {AsyncBuffer} options.file file-like object containing parquet data\n * @param {FileMetaData} [options.metadata] parquet file metadata\n * @param {string[]} [options.columns] columns to read, all columns if undefined\n * @param {string} [options.rowFormat] format of each row passed to the onComplete function\n * @param {number} [options.rowStart] first requested row index (inclusive)\n * @param {number} [options.rowEnd] last requested row index (exclusive)\n * @param {(chunk: ColumnData) => void} [options.onChunk] called when a column chunk is parsed. chunks may include row data outside the requested range.\n * @param {(rows: any[][]) => void} [options.onComplete] called when all requested rows and columns are parsed\n * @param {Compressors} [options.compressors] custom decompressors\n * @returns {Promise<void>} resolves when all requested rows and columns are parsed\n */\nexport async function parquetRead(options) {\n  if (!options.file) throw new Error('parquet file is required')\n\n  // load metadata if not provided\n  options.metadata ||= await parquetMetadataAsync(options.file)\n  if (!options.metadata) throw new Error('parquet metadata not found')\n\n  const { metadata, onComplete, rowEnd } = options\n  const rowStart = options.rowStart || 0\n  /** @type {any[][]} */\n  const rowData = []\n\n  // find which row groups to read\n  let groupStart = 0 // first row index of the current group\n  for (const rowGroup of metadata.row_groups) {\n    // number of rows in this row group\n    const groupRows = Number(rowGroup.num_rows)\n    // if row group overlaps with row range, read it\n    if (groupStart + groupRows >= rowStart && (rowEnd === undefined || groupStart < rowEnd)) {\n      // read row group\n      const rowLimit = rowEnd && rowEnd - groupStart\n      const groupData = await readRowGroup(options, rowGroup, groupStart, rowLimit)\n      if (onComplete) {\n        // filter to rows in range\n        const start = Math.max(rowStart - groupStart, 0)\n        const end = rowEnd === undefined ? undefined : rowEnd - groupStart\n        concat(rowData, groupData.slice(start, end))\n      }\n    }\n    groupStart += groupRows\n  }\n\n  if (onComplete) onComplete(rowData)\n}\n\n/**\n * Read a row group from a file-like object.\n *\n * @typedef {import('./types.js').RowGroup} RowGroup\n * @param {object} options read options\n * @param {AsyncBuffer} options.file file-like object containing parquet data\n * @param {FileMetaData} [options.metadata] parquet file metadata\n * @param {string[]} [options.columns] columns to read, all columns if undefined\n * @param {string} [options.rowFormat] format of each row passed to the onComplete function\n * @param {(chunk: ColumnData) => void} [options.onChunk] called when a column chunk is parsed. chunks may include row data outside the requested range.\n * @param {(rows: any[][]) => void} [options.onComplete] called when all requested rows and columns are parsed\n * @param {Compressors} [options.compressors]\n * @param {RowGroup} rowGroup row group to read\n * @param {number} groupStart row index of the first row in the group\n * @param {number} [rowLimit] max rows to read from this group\n * @returns {Promise<any[][]>} resolves to row data\n */\nexport async function readRowGroup(options, rowGroup, groupStart, rowLimit) {\n  const { file, metadata, columns } = options\n  if (!metadata) throw new Error('parquet metadata not found')\n  if (rowLimit === undefined || rowLimit > rowGroup.num_rows) rowLimit = Number(rowGroup.num_rows)\n\n  // loop through metadata to find min/max bytes to read\n  let [groupStartByte, groupEndByte] = [file.byteLength, 0]\n  rowGroup.columns.forEach(({ meta_data: columnMetadata }) => {\n    if (!columnMetadata) throw new Error('parquet column metadata is undefined')\n    // skip columns that are not requested\n    if (columns && !columns.includes(columnMetadata.path_in_schema[0])) return\n\n    const [columnStartByte, columnEndByte] = getColumnRange(columnMetadata).map(Number)\n    groupStartByte = Math.min(groupStartByte, columnStartByte)\n    groupEndByte = Math.max(groupEndByte, columnEndByte)\n  })\n  if (groupStartByte >= groupEndByte && columns?.length) {\n    // TODO: should throw if any column is missing\n    throw new Error(`parquet columns not found: ${columns.join(', ')}`)\n  }\n  // if row group size is less than 32mb, pre-load in one read\n  let groupBuffer\n  if (groupEndByte - groupStartByte <= 1 << 25) {\n    // pre-load row group byte data in one big read,\n    // otherwise read column data individually\n    groupBuffer = await file.slice(groupStartByte, groupEndByte)\n  }\n\n  const promises = []\n  // Top-level columns to assemble\n  const { children } = getSchemaPath(metadata.schema, [])[0]\n  const subcolumnNames = new Map(children.map(child => [child.element.name, getSubcolumns(child)]))\n  const subcolumnData = new Map() // columns to assemble as maps\n  // read column data\n  for (let columnIndex = 0; columnIndex < rowGroup.columns.length; columnIndex++) {\n    const columnMetadata = rowGroup.columns[columnIndex].meta_data\n    if (!columnMetadata) throw new Error('parquet column metadata is undefined')\n\n    // skip columns that are not requested\n    const columnName = columnMetadata.path_in_schema[0]\n    if (columns && !columns.includes(columnName)) continue\n\n    const [columnStartByte, columnEndByte] = getColumnRange(columnMetadata).map(Number)\n    const columnBytes = columnEndByte - columnStartByte\n\n    // skip columns larger than 1gb\n    // TODO: stream process the data, returning only the requested rows\n    if (columnBytes > 1 << 30) {\n      console.warn(`parquet skipping huge column \"${columnMetadata.path_in_schema}\" ${columnBytes.toLocaleString()} bytes`)\n      // TODO: set column to new Error('parquet column too large')\n      continue\n    }\n\n    // use pre-loaded row group byte data if available, else read column data\n    /** @type {Promise<ArrayBuffer>} */\n    let buffer\n    let bufferOffset = 0\n    if (groupBuffer) {\n      buffer = Promise.resolve(groupBuffer)\n      bufferOffset = columnStartByte - groupStartByte\n    } else {\n      // wrap awaitable to ensure it's a promise\n      buffer = Promise.resolve(file.slice(columnStartByte, columnEndByte))\n    }\n\n    // read column data async\n    promises.push(buffer.then(arrayBuffer => {\n      const schemaPath = getSchemaPath(metadata.schema, columnMetadata.path_in_schema)\n      const reader = { view: new DataView(arrayBuffer), offset: bufferOffset }\n      /** @type {any[] | undefined} */\n      let columnData = readColumn(reader, rowLimit, columnMetadata, schemaPath, options)\n      // assert(columnData.length === Number(rowGroup.num_rows)\n\n      // TODO: fast path for non-nested columns\n      // Save column data for assembly\n      const subcolumn = columnMetadata.path_in_schema.join('.')\n      subcolumnData.set(subcolumn, columnData)\n      columnData = undefined\n\n      const subcolumns = subcolumnNames.get(columnName)\n      if (subcolumns?.every(name => subcolumnData.has(name))) {\n        // We have all data needed to assemble a top level column\n        assembleNested(subcolumnData, schemaPath[1])\n        columnData = subcolumnData.get(columnName)\n        if (!columnData) {\n          throw new Error(`parquet column data not assembled: ${columnName}`)\n        }\n      }\n\n      // do not emit column data until structs are fully parsed\n      if (!columnData) return\n      // notify caller of column data\n      options.onChunk?.({\n        columnName,\n        columnData,\n        rowStart: groupStart,\n        rowEnd: groupStart + columnData.length,\n      })\n    }))\n  }\n  await Promise.all(promises)\n  if (options.onComplete) {\n    // transpose columns into rows\n    const groupData = new Array(rowLimit)\n    const includedColumnNames = children\n      .map(child => child.element.name)\n      .filter(name => !columns || columns.includes(name))\n    const columnOrder = columns || includedColumnNames\n    const includedColumns = columnOrder\n      .map(name => includedColumnNames.includes(name) ? subcolumnData.get(name) : undefined)\n\n    for (let row = 0; row < rowLimit; row++) {\n      if (options.rowFormat === 'object') {\n        // return each row as an object\n        /** @type {Record<string, any>} */\n        const rowData = {}\n        columnOrder.forEach((name, index) => {\n          rowData[name] = includedColumns[index]?.[row]\n        })\n        groupData[row] = rowData\n      } else {\n        // return each row as an array\n        groupData[row] = includedColumns.map(column => column?.[row])\n      }\n    }\n    return groupData\n  }\n  return []\n}\n\n\n/**\n * Return a list of sub-columns needed to construct a top-level column.\n *\n * @param {import('./types.js').SchemaTree} schema\n * @param {string[]} output\n * @returns {string[]}\n */\nfunction getSubcolumns(schema, output = []) {\n  if (schema.children.length) {\n    for (const child of schema.children) {\n      getSubcolumns(child, output)\n    }\n  } else {\n    output.push(schema.path.join('.'))\n  }\n  return output\n}\n","import { parquetReadObjects } from './hyparquet.js'\nimport { parquetMetadataAsync } from './metadata.js'\n\n/**\n * Wraps parquetRead with orderBy support.\n * This is a parquet-aware query engine that can read a subset of rows,\n * with an optional orderBy clause.\n *\n * @typedef {import('./hyparquet.js').ParquetReadOptions} ParquetReadOptions\n * @param {ParquetReadOptions & { orderBy?: string }} options\n * @returns {Promise<Record<string, any>[]>}\n */\nexport async function parquetQuery(options) {\n  const { file, rowStart, rowEnd, orderBy } = options\n  options.metadata ||= await parquetMetadataAsync(file)\n\n  // TODO: Faster path for: no orderBy, no rowStart/rowEnd, one row group\n\n  if (typeof orderBy === 'string') {\n    // Fetch orderBy column first\n    const orderColumn = await parquetReadObjects({ ...options, rowStart: undefined, rowEnd: undefined, columns: [orderBy] })\n\n    // Compute row groups to fetch\n    const sortedIndices = Array.from(orderColumn, (_, index) => index)\n      .sort((a, b) => compare(orderColumn[a][orderBy], orderColumn[b][orderBy]))\n      .slice(rowStart, rowEnd)\n\n    const sparseData = await parquetReadRows({ ...options, rows: sortedIndices })\n    const data = sortedIndices.map(index => sparseData[index])\n    return data\n  } else {\n    return await parquetReadObjects(options)\n  }\n}\n\n/**\n * Reads a list rows from a parquet file, reading only the row groups that contain the rows.\n * Returns a sparse array of rows.\n * @param {ParquetReadOptions & { rows: number[] }} options\n * @returns {Promise<Record<string, any>[]>}\n */\nasync function parquetReadRows(options) {\n  const { file, rows } = options\n  options.metadata ||= await parquetMetadataAsync(file)\n  const { row_groups: rowGroups } = options.metadata\n  // Compute row groups to fetch\n  const groupIncluded = Array(rowGroups.length).fill(false)\n  let groupStart = 0\n  const groupEnds = rowGroups.map(group => groupStart += Number(group.num_rows))\n  for (const index of rows) {\n    const groupIndex = groupEnds.findIndex(end => index < end)\n    groupIncluded[groupIndex] = true\n  }\n\n  // Compute row ranges to fetch\n  const rowRanges = []\n  let rangeStart\n  groupStart = 0\n  for (let i = 0; i < groupIncluded.length; i++) {\n    const groupEnd = groupStart + Number(rowGroups[i].num_rows)\n    if (groupIncluded[i]) {\n      if (rangeStart === undefined) {\n        rangeStart = groupStart\n      }\n    } else {\n      if (rangeStart !== undefined) {\n        rowRanges.push([rangeStart, groupEnd])\n        rangeStart = undefined\n      }\n    }\n    groupStart = groupEnd\n  }\n  if (rangeStart !== undefined) {\n    rowRanges.push([rangeStart, groupStart])\n  }\n\n  // Fetch by row group and map to rows\n  const sparseData = new Array(Number(options.metadata.num_rows))\n  for (const [rangeStart, rangeEnd] of rowRanges) {\n    // TODO: fetch in parallel\n    const groupData = await parquetReadObjects({ ...options, rowStart: rangeStart, rowEnd: rangeEnd })\n    for (let i = rangeStart; i < rangeEnd; i++) {\n      sparseData[i] = groupData[i - rangeStart]\n      sparseData[i].__index__ = i\n    }\n  }\n  return sparseData\n}\n\n/**\n * @param {any} a\n * @param {any} b\n * @returns {number}\n */\nfunction compare(a, b) {\n  if (a < b) return -1\n  if (a > b) return 1\n  return 1 // TODO: how to handle nulls?\n}\n","export { parquetMetadata, parquetMetadataAsync, parquetSchema } from './metadata.js'\n\nimport { parquetRead } from './read.js'\nexport { parquetRead }\n\nexport { parquetQuery } from './query.js'\n\nexport { snappyUncompress } from './snappy.js'\n\nexport { asyncBufferFromFile, asyncBufferFromUrl, byteLengthFromUrl, toJson } from './utils.js'\n\n/**\n * @param {import('./hyparquet.js').ParquetReadOptions} options\n * @returns {Promise<Array<Record<string, any>>>}\n */\nexport function parquetReadObjects(options) {\n  return new Promise((onComplete, reject) => {\n    parquetRead({\n      rowFormat: 'object',\n      ...options,\n      onComplete,\n    }).catch(reject)\n  })\n}\n","// Some numerical data is initialized as -1 even when it doesn't need initialization to help the JIT infer types\n// aliases for shorter compressed code (most minifers don't do this)\nvar ab = ArrayBuffer, u8 = Uint8Array, u16 = Uint16Array, i16 = Int16Array, u32 = Uint32Array, i32 = Int32Array;\nvar slc = function (v, s, e) {\n    if (u8.prototype.slice)\n        return u8.prototype.slice.call(v, s, e);\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    var n = new u8(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\nvar fill = function (v, n, s, e) {\n    if (u8.prototype.fill)\n        return u8.prototype.fill.call(v, n, s, e);\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    for (; s < e; ++s)\n        v[s] = n;\n    return v;\n};\nvar cpw = function (v, t, s, e) {\n    if (u8.prototype.copyWithin)\n        return u8.prototype.copyWithin.call(v, t, s, e);\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    while (s < e) {\n        v[t++] = v[s++];\n    }\n};\n/**\n * Codes for errors generated within this library\n */\nexport var ZstdErrorCode = {\n    InvalidData: 0,\n    WindowSizeTooLarge: 1,\n    InvalidBlockType: 2,\n    FSEAccuracyTooHigh: 3,\n    DistanceTooFarBack: 4,\n    UnexpectedEOF: 5\n};\n// error codes\nvar ec = [\n    'invalid zstd data',\n    'window size too large (>2046MB)',\n    'invalid block type',\n    'FSE accuracy too high',\n    'match distance too far back',\n    'unexpected EOF'\n];\nvar err = function (ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n        Error.captureStackTrace(e, err);\n    if (!nt)\n        throw e;\n    return e;\n};\nvar rb = function (d, b, n) {\n    var i = 0, o = 0;\n    for (; i < n; ++i)\n        o |= d[b++] << (i << 3);\n    return o;\n};\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\n// read Zstandard frame header\nvar rzfh = function (dat, w) {\n    var n3 = dat[0] | (dat[1] << 8) | (dat[2] << 16);\n    if (n3 == 0x2FB528 && dat[3] == 253) {\n        // Zstandard\n        var flg = dat[4];\n        //    single segment       checksum             dict flag     frame content flag\n        var ss = (flg >> 5) & 1, cc = (flg >> 2) & 1, df = flg & 3, fcf = flg >> 6;\n        if (flg & 8)\n            err(0);\n        // byte\n        var bt = 6 - ss;\n        // dict bytes\n        var db = df == 3 ? 4 : df;\n        // dictionary id\n        var di = rb(dat, bt, db);\n        bt += db;\n        // frame size bytes\n        var fsb = fcf ? (1 << fcf) : ss;\n        // frame source size\n        var fss = rb(dat, bt, fsb) + ((fcf == 1) && 256);\n        // window size\n        var ws = fss;\n        if (!ss) {\n            // window descriptor\n            var wb = 1 << (10 + (dat[5] >> 3));\n            ws = wb + (wb >> 3) * (dat[5] & 7);\n        }\n        if (ws > 2145386496)\n            err(1);\n        var buf = new u8((w == 1 ? (fss || ws) : w ? 0 : ws) + 12);\n        buf[0] = 1, buf[4] = 4, buf[8] = 8;\n        return {\n            b: bt + fsb,\n            y: 0,\n            l: 0,\n            d: di,\n            w: (w && w != 1) ? w : buf.subarray(12),\n            e: ws,\n            o: new i32(buf.buffer, 0, 3),\n            u: fss,\n            c: cc,\n            m: Math.min(131072, ws)\n        };\n    }\n    else if (((n3 >> 4) | (dat[3] << 20)) == 0x184D2A5) {\n        // skippable\n        return b4(dat, 4) + 8;\n    }\n    err(0);\n};\n// most significant bit for nonzero\nvar msb = function (val) {\n    var bits = 0;\n    for (; (1 << bits) <= val; ++bits)\n        ;\n    return bits - 1;\n};\n// read finite state entropy\nvar rfse = function (dat, bt, mal) {\n    // table pos\n    var tpos = (bt << 3) + 4;\n    // accuracy log\n    var al = (dat[bt] & 15) + 5;\n    if (al > mal)\n        err(3);\n    // size\n    var sz = 1 << al;\n    // probabilities symbols  repeat   index   high threshold\n    var probs = sz, sym = -1, re = -1, i = -1, ht = sz;\n    // optimization: single allocation is much faster\n    var buf = new ab(512 + (sz << 2));\n    var freq = new i16(buf, 0, 256);\n    // same view as freq\n    var dstate = new u16(buf, 0, 256);\n    var nstate = new u16(buf, 512, sz);\n    var bb1 = 512 + (sz << 1);\n    var syms = new u8(buf, bb1, sz);\n    var nbits = new u8(buf, bb1 + sz);\n    while (sym < 255 && probs > 0) {\n        var bits = msb(probs + 1);\n        var cbt = tpos >> 3;\n        // mask\n        var msk = (1 << (bits + 1)) - 1;\n        var val = ((dat[cbt] | (dat[cbt + 1] << 8) | (dat[cbt + 2] << 16)) >> (tpos & 7)) & msk;\n        // mask (1 fewer bit)\n        var msk1fb = (1 << bits) - 1;\n        // max small value\n        var msv = msk - probs - 1;\n        // small value\n        var sval = val & msk1fb;\n        if (sval < msv)\n            tpos += bits, val = sval;\n        else {\n            tpos += bits + 1;\n            if (val > msk1fb)\n                val -= msv;\n        }\n        freq[++sym] = --val;\n        if (val == -1) {\n            probs += val;\n            syms[--ht] = sym;\n        }\n        else\n            probs -= val;\n        if (!val) {\n            do {\n                // repeat byte\n                var rbt = tpos >> 3;\n                re = ((dat[rbt] | (dat[rbt + 1] << 8)) >> (tpos & 7)) & 3;\n                tpos += 2;\n                sym += re;\n            } while (re == 3);\n        }\n    }\n    if (sym > 255 || probs)\n        err(0);\n    var sympos = 0;\n    // sym step (coprime with sz - formula from zstd source)\n    var sstep = (sz >> 1) + (sz >> 3) + 3;\n    // sym mask\n    var smask = sz - 1;\n    for (var s = 0; s <= sym; ++s) {\n        var sf = freq[s];\n        if (sf < 1) {\n            dstate[s] = -sf;\n            continue;\n        }\n        // This is split into two loops in zstd to avoid branching, but as JS is higher-level that is unnecessary\n        for (i = 0; i < sf; ++i) {\n            syms[sympos] = s;\n            do {\n                sympos = (sympos + sstep) & smask;\n            } while (sympos >= ht);\n        }\n    }\n    // After spreading symbols, should be zero again\n    if (sympos)\n        err(0);\n    for (i = 0; i < sz; ++i) {\n        // next state\n        var ns = dstate[syms[i]]++;\n        // num bits\n        var nb = nbits[i] = al - msb(ns);\n        nstate[i] = (ns << nb) - sz;\n    }\n    return [(tpos + 7) >> 3, {\n            b: al,\n            s: syms,\n            n: nbits,\n            t: nstate\n        }];\n};\n// read huffman\nvar rhu = function (dat, bt) {\n    //  index  weight count\n    var i = 0, wc = -1;\n    //    buffer             header byte\n    var buf = new u8(292), hb = dat[bt];\n    // huffman weights\n    var hw = buf.subarray(0, 256);\n    // rank count\n    var rc = buf.subarray(256, 268);\n    // rank index\n    var ri = new u16(buf.buffer, 268);\n    // NOTE: at this point bt is 1 less than expected\n    if (hb < 128) {\n        // end byte, fse decode table\n        var _a = rfse(dat, bt + 1, 6), ebt = _a[0], fdt = _a[1];\n        bt += hb;\n        var epos = ebt << 3;\n        // last byte\n        var lb = dat[bt];\n        if (!lb)\n            err(0);\n        //  state1   state2   state1 bits   state2 bits\n        var st1 = 0, st2 = 0, btr1 = fdt.b, btr2 = btr1;\n        // fse pos\n        // pre-increment to account for original deficit of 1\n        var fpos = (++bt << 3) - 8 + msb(lb);\n        for (;;) {\n            fpos -= btr1;\n            if (fpos < epos)\n                break;\n            var cbt = fpos >> 3;\n            st1 += ((dat[cbt] | (dat[cbt + 1] << 8)) >> (fpos & 7)) & ((1 << btr1) - 1);\n            hw[++wc] = fdt.s[st1];\n            fpos -= btr2;\n            if (fpos < epos)\n                break;\n            cbt = fpos >> 3;\n            st2 += ((dat[cbt] | (dat[cbt + 1] << 8)) >> (fpos & 7)) & ((1 << btr2) - 1);\n            hw[++wc] = fdt.s[st2];\n            btr1 = fdt.n[st1];\n            st1 = fdt.t[st1];\n            btr2 = fdt.n[st2];\n            st2 = fdt.t[st2];\n        }\n        if (++wc > 255)\n            err(0);\n    }\n    else {\n        wc = hb - 127;\n        for (; i < wc; i += 2) {\n            var byte = dat[++bt];\n            hw[i] = byte >> 4;\n            hw[i + 1] = byte & 15;\n        }\n        ++bt;\n    }\n    // weight exponential sum\n    var wes = 0;\n    for (i = 0; i < wc; ++i) {\n        var wt = hw[i];\n        // bits must be at most 11, same as weight\n        if (wt > 11)\n            err(0);\n        wes += wt && (1 << (wt - 1));\n    }\n    // max bits\n    var mb = msb(wes) + 1;\n    // table size\n    var ts = 1 << mb;\n    // remaining sum\n    var rem = ts - wes;\n    // must be power of 2\n    if (rem & (rem - 1))\n        err(0);\n    hw[wc++] = msb(rem) + 1;\n    for (i = 0; i < wc; ++i) {\n        var wt = hw[i];\n        ++rc[hw[i] = wt && (mb + 1 - wt)];\n    }\n    // huf buf\n    var hbuf = new u8(ts << 1);\n    //    symbols                      num bits\n    var syms = hbuf.subarray(0, ts), nb = hbuf.subarray(ts);\n    ri[mb] = 0;\n    for (i = mb; i > 0; --i) {\n        var pv = ri[i];\n        fill(nb, i, pv, ri[i - 1] = pv + rc[i] * (1 << (mb - i)));\n    }\n    if (ri[0] != ts)\n        err(0);\n    for (i = 0; i < wc; ++i) {\n        var bits = hw[i];\n        if (bits) {\n            var code = ri[bits];\n            fill(syms, i, code, ri[bits] = code + (1 << (mb - bits)));\n        }\n    }\n    return [bt, {\n            n: nb,\n            b: mb,\n            s: syms\n        }];\n};\n// Tables generated using this:\n// https://gist.github.com/101arrowz/a979452d4355992cbf8f257cbffc9edd\n// default literal length table\nvar dllt = /*#__PURE__*/ rfse(/*#__PURE__*/ new u8([\n    81, 16, 99, 140, 49, 198, 24, 99, 12, 33, 196, 24, 99, 102, 102, 134, 70, 146, 4\n]), 0, 6)[1];\n// default match length table\nvar dmlt = /*#__PURE__*/ rfse(/*#__PURE__*/ new u8([\n    33, 20, 196, 24, 99, 140, 33, 132, 16, 66, 8, 33, 132, 16, 66, 8, 33, 68, 68, 68, 68, 68, 68, 68, 68, 36, 9\n]), 0, 6)[1];\n// default offset code table\nvar doct = /*#__PURE__ */ rfse(/*#__PURE__*/ new u8([\n    32, 132, 16, 66, 102, 70, 68, 68, 68, 68, 36, 73, 2\n]), 0, 5)[1];\n// bits to baseline\nvar b2bl = function (b, s) {\n    var len = b.length, bl = new i32(len);\n    for (var i = 0; i < len; ++i) {\n        bl[i] = s;\n        s += 1 << b[i];\n    }\n    return bl;\n};\n// literal length bits\nvar llb = /*#__PURE__ */ new u8(( /*#__PURE__ */new i32([\n    0, 0, 0, 0, 16843009, 50528770, 134678020, 202050057, 269422093\n])).buffer, 0, 36);\n// literal length baseline\nvar llbl = /*#__PURE__ */ b2bl(llb, 0);\n// match length bits\nvar mlb = /*#__PURE__ */ new u8(( /*#__PURE__ */new i32([\n    0, 0, 0, 0, 0, 0, 0, 0, 16843009, 50528770, 117769220, 185207048, 252579084, 16\n])).buffer, 0, 53);\n// match length baseline\nvar mlbl = /*#__PURE__ */ b2bl(mlb, 3);\n// decode huffman stream\nvar dhu = function (dat, out, hu) {\n    var len = dat.length, ss = out.length, lb = dat[len - 1], msk = (1 << hu.b) - 1, eb = -hu.b;\n    if (!lb)\n        err(0);\n    var st = 0, btr = hu.b, pos = (len << 3) - 8 + msb(lb) - btr, i = -1;\n    for (; pos > eb && i < ss;) {\n        var cbt = pos >> 3;\n        var val = (dat[cbt] | (dat[cbt + 1] << 8) | (dat[cbt + 2] << 16)) >> (pos & 7);\n        st = ((st << btr) | val) & msk;\n        out[++i] = hu.s[st];\n        pos -= (btr = hu.n[st]);\n    }\n    if (pos != eb || i + 1 != ss)\n        err(0);\n};\n// decode huffman stream 4x\n// TODO: use workers to parallelize\nvar dhu4 = function (dat, out, hu) {\n    var bt = 6;\n    var ss = out.length, sz1 = (ss + 3) >> 2, sz2 = sz1 << 1, sz3 = sz1 + sz2;\n    dhu(dat.subarray(bt, bt += dat[0] | (dat[1] << 8)), out.subarray(0, sz1), hu);\n    dhu(dat.subarray(bt, bt += dat[2] | (dat[3] << 8)), out.subarray(sz1, sz2), hu);\n    dhu(dat.subarray(bt, bt += dat[4] | (dat[5] << 8)), out.subarray(sz2, sz3), hu);\n    dhu(dat.subarray(bt), out.subarray(sz3), hu);\n};\n// read Zstandard block\nvar rzb = function (dat, st, out) {\n    var _a;\n    var bt = st.b;\n    //    byte 0        block type\n    var b0 = dat[bt], btype = (b0 >> 1) & 3;\n    st.l = b0 & 1;\n    var sz = (b0 >> 3) | (dat[bt + 1] << 5) | (dat[bt + 2] << 13);\n    // end byte for block\n    var ebt = (bt += 3) + sz;\n    if (btype == 1) {\n        if (bt >= dat.length)\n            return;\n        st.b = bt + 1;\n        if (out) {\n            fill(out, dat[bt], st.y, st.y += sz);\n            return out;\n        }\n        return fill(new u8(sz), dat[bt]);\n    }\n    if (ebt > dat.length)\n        return;\n    if (btype == 0) {\n        st.b = ebt;\n        if (out) {\n            out.set(dat.subarray(bt, ebt), st.y);\n            st.y += sz;\n            return out;\n        }\n        return slc(dat, bt, ebt);\n    }\n    if (btype == 2) {\n        //    byte 3        lit btype     size format\n        var b3 = dat[bt], lbt = b3 & 3, sf = (b3 >> 2) & 3;\n        // lit src size  lit cmp sz 4 streams\n        var lss = b3 >> 4, lcs = 0, s4 = 0;\n        if (lbt < 2) {\n            if (sf & 1)\n                lss |= (dat[++bt] << 4) | ((sf & 2) && (dat[++bt] << 12));\n            else\n                lss = b3 >> 3;\n        }\n        else {\n            s4 = sf;\n            if (sf < 2)\n                lss |= ((dat[++bt] & 63) << 4), lcs = (dat[bt] >> 6) | (dat[++bt] << 2);\n            else if (sf == 2)\n                lss |= (dat[++bt] << 4) | ((dat[++bt] & 3) << 12), lcs = (dat[bt] >> 2) | (dat[++bt] << 6);\n            else\n                lss |= (dat[++bt] << 4) | ((dat[++bt] & 63) << 12), lcs = (dat[bt] >> 6) | (dat[++bt] << 2) | (dat[++bt] << 10);\n        }\n        ++bt;\n        // add literals to end - can never overlap with backreferences because unused literals always appended\n        var buf = out ? out.subarray(st.y, st.y + st.m) : new u8(st.m);\n        // starting point for literals\n        var spl = buf.length - lss;\n        if (lbt == 0)\n            buf.set(dat.subarray(bt, bt += lss), spl);\n        else if (lbt == 1)\n            fill(buf, dat[bt++], spl);\n        else {\n            // huffman table\n            var hu = st.h;\n            if (lbt == 2) {\n                var hud = rhu(dat, bt);\n                // subtract description length\n                lcs += bt - (bt = hud[0]);\n                st.h = hu = hud[1];\n            }\n            else if (!hu)\n                err(0);\n            (s4 ? dhu4 : dhu)(dat.subarray(bt, bt += lcs), buf.subarray(spl), hu);\n        }\n        // num sequences\n        var ns = dat[bt++];\n        if (ns) {\n            if (ns == 255)\n                ns = (dat[bt++] | (dat[bt++] << 8)) + 0x7F00;\n            else if (ns > 127)\n                ns = ((ns - 128) << 8) | dat[bt++];\n            // symbol compression modes\n            var scm = dat[bt++];\n            if (scm & 3)\n                err(0);\n            var dts = [dmlt, doct, dllt];\n            for (var i = 2; i > -1; --i) {\n                var md = (scm >> ((i << 1) + 2)) & 3;\n                if (md == 1) {\n                    // rle buf\n                    var rbuf = new u8([0, 0, dat[bt++]]);\n                    dts[i] = {\n                        s: rbuf.subarray(2, 3),\n                        n: rbuf.subarray(0, 1),\n                        t: new u16(rbuf.buffer, 0, 1),\n                        b: 0\n                    };\n                }\n                else if (md == 2) {\n                    // accuracy log 8 for offsets, 9 for others\n                    _a = rfse(dat, bt, 9 - (i & 1)), bt = _a[0], dts[i] = _a[1];\n                }\n                else if (md == 3) {\n                    if (!st.t)\n                        err(0);\n                    dts[i] = st.t[i];\n                }\n            }\n            var _b = st.t = dts, mlt = _b[0], oct = _b[1], llt = _b[2];\n            var lb = dat[ebt - 1];\n            if (!lb)\n                err(0);\n            var spos = (ebt << 3) - 8 + msb(lb) - llt.b, cbt = spos >> 3, oubt = 0;\n            var lst = ((dat[cbt] | (dat[cbt + 1] << 8)) >> (spos & 7)) & ((1 << llt.b) - 1);\n            cbt = (spos -= oct.b) >> 3;\n            var ost = ((dat[cbt] | (dat[cbt + 1] << 8)) >> (spos & 7)) & ((1 << oct.b) - 1);\n            cbt = (spos -= mlt.b) >> 3;\n            var mst = ((dat[cbt] | (dat[cbt + 1] << 8)) >> (spos & 7)) & ((1 << mlt.b) - 1);\n            for (++ns; --ns;) {\n                var llc = llt.s[lst];\n                var lbtr = llt.n[lst];\n                var mlc = mlt.s[mst];\n                var mbtr = mlt.n[mst];\n                var ofc = oct.s[ost];\n                var obtr = oct.n[ost];\n                cbt = (spos -= ofc) >> 3;\n                var ofp = 1 << ofc;\n                var off = ofp + (((dat[cbt] | (dat[cbt + 1] << 8) | (dat[cbt + 2] << 16) | (dat[cbt + 3] << 24)) >>> (spos & 7)) & (ofp - 1));\n                cbt = (spos -= mlb[mlc]) >> 3;\n                var ml = mlbl[mlc] + (((dat[cbt] | (dat[cbt + 1] << 8) | (dat[cbt + 2] << 16)) >> (spos & 7)) & ((1 << mlb[mlc]) - 1));\n                cbt = (spos -= llb[llc]) >> 3;\n                var ll = llbl[llc] + (((dat[cbt] | (dat[cbt + 1] << 8) | (dat[cbt + 2] << 16)) >> (spos & 7)) & ((1 << llb[llc]) - 1));\n                cbt = (spos -= lbtr) >> 3;\n                lst = llt.t[lst] + (((dat[cbt] | (dat[cbt + 1] << 8)) >> (spos & 7)) & ((1 << lbtr) - 1));\n                cbt = (spos -= mbtr) >> 3;\n                mst = mlt.t[mst] + (((dat[cbt] | (dat[cbt + 1] << 8)) >> (spos & 7)) & ((1 << mbtr) - 1));\n                cbt = (spos -= obtr) >> 3;\n                ost = oct.t[ost] + (((dat[cbt] | (dat[cbt + 1] << 8)) >> (spos & 7)) & ((1 << obtr) - 1));\n                if (off > 3) {\n                    st.o[2] = st.o[1];\n                    st.o[1] = st.o[0];\n                    st.o[0] = off -= 3;\n                }\n                else {\n                    var idx = off - (ll != 0);\n                    if (idx) {\n                        off = idx == 3 ? st.o[0] - 1 : st.o[idx];\n                        if (idx > 1)\n                            st.o[2] = st.o[1];\n                        st.o[1] = st.o[0];\n                        st.o[0] = off;\n                    }\n                    else\n                        off = st.o[0];\n                }\n                for (var i = 0; i < ll; ++i) {\n                    buf[oubt + i] = buf[spl + i];\n                }\n                oubt += ll, spl += ll;\n                var stin = oubt - off;\n                if (stin < 0) {\n                    var len = -stin;\n                    var bs = st.e + stin;\n                    if (len > ml)\n                        len = ml;\n                    for (var i = 0; i < len; ++i) {\n                        buf[oubt + i] = st.w[bs + i];\n                    }\n                    oubt += len, ml -= len, stin = 0;\n                }\n                for (var i = 0; i < ml; ++i) {\n                    buf[oubt + i] = buf[stin + i];\n                }\n                oubt += ml;\n            }\n            if (oubt != spl) {\n                while (spl < buf.length) {\n                    buf[oubt++] = buf[spl++];\n                }\n            }\n            else\n                oubt = buf.length;\n            if (out)\n                st.y += oubt;\n            else\n                buf = slc(buf, 0, oubt);\n        }\n        else if (out) {\n            st.y += lss;\n            if (spl) {\n                for (var i = 0; i < lss; ++i) {\n                    buf[i] = buf[spl + i];\n                }\n            }\n        }\n        else if (spl)\n            buf = slc(buf, spl);\n        st.b = ebt;\n        return buf;\n    }\n    err(2);\n};\n// concat\nvar cct = function (bufs, ol) {\n    if (bufs.length == 1)\n        return bufs[0];\n    var buf = new u8(ol);\n    for (var i = 0, b = 0; i < bufs.length; ++i) {\n        var chk = bufs[i];\n        buf.set(chk, b);\n        b += chk.length;\n    }\n    return buf;\n};\n/**\n * Decompresses Zstandard data\n * @param dat The input data\n * @param buf The output buffer. If unspecified, the function will allocate\n *            exactly enough memory to fit the decompressed data. If your\n *            data has multiple frames and you know the output size, specifying\n *            it will yield better performance.\n * @returns The decompressed data\n */\nexport function decompress(dat, buf) {\n    var bufs = [], nb = +!buf;\n    var bt = 0, ol = 0;\n    for (; dat.length;) {\n        var st = rzfh(dat, nb || buf);\n        if (typeof st == 'object') {\n            if (nb) {\n                buf = null;\n                if (st.w.length == st.u) {\n                    bufs.push(buf = st.w);\n                    ol += st.u;\n                }\n            }\n            else {\n                bufs.push(buf);\n                st.e = 0;\n            }\n            for (; !st.l;) {\n                var blk = rzb(dat, st, buf);\n                if (!blk)\n                    err(5);\n                if (buf)\n                    st.e = st.y;\n                else {\n                    bufs.push(blk);\n                    ol += blk.length;\n                    cpw(st.w, 0, blk.length);\n                    st.w.set(blk, st.w.length - blk.length);\n                }\n            }\n            bt = st.b + (st.c * 4);\n        }\n        else\n            bt = st;\n        dat = dat.subarray(bt);\n    }\n    return cct(bufs, ol);\n}\n/**\n * Decompressor for Zstandard streamed data\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zstandard decompressor\n     * @param ondata The handler for stream data\n     */\n    function Decompress(ondata) {\n        this.ondata = ondata;\n        this.c = [];\n        this.l = 0;\n        this.z = 0;\n    }\n    /**\n     * Pushes data to be decompressed\n     * @param chunk The chunk of data to push\n     * @param final Whether or not this is the last chunk in the stream\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (typeof this.s == 'number') {\n            var sub = Math.min(chunk.length, this.s);\n            chunk = chunk.subarray(sub);\n            this.s -= sub;\n        }\n        var sl = chunk.length;\n        var ncs = sl + this.l;\n        if (!this.s) {\n            if (final) {\n                if (!ncs) {\n                    this.ondata(new u8(0), true);\n                    return;\n                }\n                // min for frame + one block\n                if (ncs < 5)\n                    err(5);\n            }\n            else if (ncs < 18) {\n                this.c.push(chunk);\n                this.l = ncs;\n                return;\n            }\n            if (this.l) {\n                this.c.push(chunk);\n                chunk = cct(this.c, ncs);\n                this.c = [];\n                this.l = 0;\n            }\n            if (typeof (this.s = rzfh(chunk)) == 'number')\n                return this.push(chunk, final);\n        }\n        if (typeof this.s != 'number') {\n            if (ncs < (this.z || 3)) {\n                if (final)\n                    err(5);\n                this.c.push(chunk);\n                this.l = ncs;\n                return;\n            }\n            if (this.l) {\n                this.c.push(chunk);\n                chunk = cct(this.c, ncs);\n                this.c = [];\n                this.l = 0;\n            }\n            if (!this.z && ncs < (this.z = (chunk[this.s.b] & 2) ? 4 : 3 + ((chunk[this.s.b] >> 3) | (chunk[this.s.b + 1] << 5) | (chunk[this.s.b + 2] << 13)))) {\n                if (final)\n                    err(5);\n                this.c.push(chunk);\n                this.l = ncs;\n                return;\n            }\n            else\n                this.z = 0;\n            for (;;) {\n                var blk = rzb(chunk, this.s);\n                if (!blk) {\n                    if (final)\n                        err(5);\n                    var adc = chunk.subarray(this.s.b);\n                    this.s.b = 0;\n                    this.c.push(adc), this.l += adc.length;\n                    return;\n                }\n                else {\n                    this.ondata(blk, false);\n                    cpw(this.s.w, 0, blk.length);\n                    this.s.w.set(blk, this.s.w.length - blk.length);\n                }\n                if (this.s.l) {\n                    var rest = chunk.subarray(this.s.b);\n                    this.s = this.s.c * 4;\n                    this.push(rest, final);\n                    return;\n                }\n            }\n        }\n        else if (final)\n            err(5);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n","/**\n * Uncompress a snappy compressed buffer.\n *\n * @param {Uint8Array} input\n * @param {number} outputLength\n * @returns {Uint8Array}\n */\nexport function snappyUncompress(input, outputLength) {\n  return snappyUncompressor()(input, outputLength)\n}\n\n/**\n * Load wasm and return uncompressor function.\n *\n * @returns {(input: Uint8Array, outputLength: number) => Uint8Array}\n */\nexport function snappyUncompressor() {\n  // Instantiate wasm module\n  const wasm = instantiateWasm()\n\n  return (input, outputLength) => {\n    /** @type {any} */\n    const { memory, uncompress } = wasm.exports\n\n    // Input data is passed into wasm memory at inputStart\n    // Output data is expected to be written to wasm memory at outputStart\n    // clang uses some wasm memory, so we need to skip past that\n    const inputStart = 68000 // 68 kb\n    const outputStart = inputStart + input.byteLength\n\n    // WebAssembly memory\n    const totalSize = inputStart + input.byteLength + outputLength\n    if (memory.buffer.byteLength < totalSize) {\n      // Calculate the number of pages needed, rounding up\n      const pageSize = 64 * 1024 // 64KiB per page\n      const currentPages = memory.buffer.byteLength / pageSize\n      const requiredPages = Math.ceil(totalSize / pageSize)\n      const pagesToGrow = requiredPages - currentPages\n      memory.grow(pagesToGrow)\n    }\n\n    // Copy the compressed data to WASM memory\n    const byteArray = new Uint8Array(memory.buffer)\n    byteArray.set(input, inputStart)\n\n    // Call wasm uncompress function\n    const result = uncompress(inputStart, input.byteLength, outputStart)\n\n    // Check for errors\n    if (result === -1) throw new Error('invalid snappy length header')\n    if (result === -2) throw new Error('missing eof marker')\n    if (result === -3) throw new Error('premature end of input')\n    if (result) throw new Error(`failed to uncompress data ${result}`)\n\n    // Get uncompressed data from WASM memory\n    return byteArray.slice(outputStart, outputStart + outputLength)\n  }\n}\n\n/**\n * Instantiate WASM module from a base64 string.\n *\n * @returns {WebAssembly.Instance}\n */\nfunction instantiateWasm() {\n  const binaryString = atob(wasm64)\n  const byteArray = new Uint8Array(binaryString.length)\n  for (let i = 0; i < binaryString.length; i += 1) {\n    byteArray[i] = binaryString.charCodeAt(i)\n  }\n  // only works for payload less than 4kb:\n  const mod = new WebAssembly.Module(byteArray)\n  return new WebAssembly.Instance(mod)\n}\n\n// Base64 encoded hysnappy.wasm\nconst wasm64 = 'AGFzbQEAAAABEANgAABgA39/fwF/YAF/AX8DBgUAAQEBAgUDAQACBj8KfwFBoIwEC38AQYAIC38AQaAMC38AQaAMC38AQaCMBAt/AEGACAt/AEGgjAQLfwBBgIAIC38AQQALfwBBAQsHwQEOBm1lbW9yeQIAEV9fd2FzbV9jYWxsX2N0b3JzAAAGbWVtY3B5AAEHbWVtbW92ZQACCnVuY29tcHJlc3MAAwxfX2Rzb19oYW5kbGUDAQpfX2RhdGFfZW5kAwILX19zdGFja19sb3cDAwxfX3N0YWNrX2hpZ2gDBA1fX2dsb2JhbF9iYXNlAwULX19oZWFwX2Jhc2UDBgpfX2hlYXBfZW5kAwcNX19tZW1vcnlfYmFzZQMIDF9fdGFibGVfYmFzZQMJCuASBQIAC8sBAQN/AkAgAkUNAAJAAkAgAkEHcSIDDQAgACEEIAIhBQwBCyAAIQQgAiEFA0AgBCABLQAAOgAAIARBAWohBCABQQFqIQEgBUF/aiEFIANBf2oiAw0ACwsgAkEISQ0AA0AgBCABLQAAOgAAIAQgAS0AAToAASAEIAEtAAI6AAIgBCABLQADOgADIAQgAS0ABDoABCAEIAEtAAU6AAUgBCABLQAGOgAGIAQgAS0ABzoAByAEQQhqIQQgAUEIaiEBIAVBeGoiBQ0ACwsgAAugAwEEfwJAIAAgAUYNAAJAAkAgACABSQ0AIAEgAmoiAyAASw0BCyACRQ0BAkACQCACQQdxIgMNACAAIQQgAiEFDAELIAAhBCACIQUDQCAEIAEtAAA6AAAgBEEBaiEEIAFBAWohASAFQX9qIQUgA0F/aiIDDQALCyACQQhJDQEDQCAEIAEtAAA6AAAgBCABLQABOgABIAQgAS0AAjoAAiAEIAEtAAM6AAMgBCABLQAEOgAEIAQgAS0ABToABSAEIAEtAAY6AAYgBCABLQAHOgAHIARBCGohBCABQQhqIQEgBUF4aiIFDQAMAgsLIAJFDQACQAJAIAJBA3EiBA0AIAAgAmohBiACIQUMAQsgAiEFA0AgBUF/aiIFIABqIgYgBSABaiIDLQAAOgAAIARBf2oiBA0ACwsgAkEESQ0AIAZBfGohASADQXxqIQQDQCABQQNqIARBA2otAAA6AAAgAUECaiAEQQJqLQAAOgAAIAFBAWogBEEBai0AADoAACABIAQtAAA6AAAgAUF8aiEBIARBfGohBCAFQXxqIgUNAAsLIAALswoBCX8jgICAgABBIGsiAySAgICAACADQQlqQgA3AAAgA0IANwIEIAMgA0EYajYCAEF/IQQCQCABRQ0AIAMgAUF/aiIFNgIcIAMgAEEBajYCGCAALAAAIgZB/wBxIQcCQCAGQX9KDQAgBUUNASADIAFBfmoiBTYCHCADIABBAmo2AhggACwAASIGQf8AcUEHdCAHciEHQX8hBCAGQX9KDQAgBUUNASADIAFBfWoiBTYCHCADIABBA2o2AhggACwAAiIGQf8AcUEOdCAHciEHQX8hBCAGQX9KDQAgBUUNASADIAFBfGoiBTYCHCADIABBBGo2AhggACwAAyIGQf8AcUEVdCAHciEHQX8hBCAGQX9KDQAgBUUNASADIAFBe2o2AhwgAyAAQQVqNgIYIAAsAAQiAUEASA0BIAFBHHQgB3IhBwsgAiAHaiEIAkACQCADEISAgIAADQAgAiEADAELIAMoAgQhASACIQADQAJAIAMoAgggAWtBBEoNACADIAE2AgQgAxCEgICAAEUNAiADKAIEIQELIAFBAWohBQJAAkAgAS0AACIGQQNxDQAgCCAAayEJIAMoAggiCiAFayEEIAZBAnYiC0EBaiEHAkAgBkE/Sw0AIARBEEkNACAJQRBIDQAgACABKAIBNgIAIAAgASgCBTYCBCAAIAEoAgk2AgggACABKAINNgIMIAAgB2ohACADKAIIIAUgB2oiAWtBBEoNAyADIAE2AgQgAxCEgICAAEUNBAwCCwJAAkAgBkHwAU8NACAFIQYMAQsgCiAFIAtBRWoiAWoiBmshBCABQQJ0QYCIgIAAaigCACAFKAIAcUEBaiEHCwJAIAcgBE0NAANAIAggAGsgBEkNBSAAIAYgBBCBgICAACEAIAMoAgAiASABKAIAIgkgAygCDCIFaiIGNgIAIAFBBGoiASABKAIAIgogBWsiATYCACADIAE2AgwgACAEaiEAIAFFDQUgAyAJIApqNgIIIAcgBGshByABIQQgByABSw0ACyAIIABrIQkLIAkgB0kNAyAAIAYgBxCBgICAACAHaiEAIAMoAgggBiAHaiIBa0EESg0CIAMgATYCBCADEISAgIAADQEMAwsgACACayAGQQF0QaCIgIAAai8BACIBQQt2IgpBAnRBgIiAgABq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'\n","/* Copyright 2013 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n   Bit reading helpers\n*/\n\nconst BROTLI_READ_SIZE = 4096\nconst BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32\nconst BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1\n\nconst kBitMask = new Uint32Array([\n  0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767,\n  65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215,\n])\n\n/**\n * Input byte buffer, consist of a ringbuffer and a \"slack\" region where\n * bytes from the start of the ringbuffer are copied.\n *\n * @typedef {import('./brotliStreams.js').BrotliInput} BrotliInput\n * @param {BrotliInput} input\n */\nfunction BrotliBitReader(input) {\n  this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE)\n  this.input_ = input /* input callback */\n\n  this.buf_ptr_ = 0 /* next input will write here */\n  this.val_ = 0 /* pre-fetched bits */\n  this.pos_ = 0 /* byte position in stream */\n\n  this.reset()\n}\n\nBrotliBitReader.READ_SIZE = BROTLI_READ_SIZE\nBrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK\n\nBrotliBitReader.prototype.reset = function() {\n  this.buf_ptr_ = 0 /* next input will write here */\n  this.val_ = 0 /* pre-fetched bits */\n  this.pos_ = 0 /* byte position in stream */\n  this.bit_pos_ = 0 /* current bit-reading position in val_ */\n  this.bit_end_pos_ = 0 /* bit-reading end position from LSB of val_ */\n  this.eos_ = 0 /* input stream is finished */\n\n  this.readMoreInput()\n  for (let i = 0; i < 4; i++) {\n    this.val_ |= this.buf_[this.pos_] << 8 * i\n    this.pos_++\n  }\n\n  return this.bit_end_pos_ > 0\n}\n\n/**\n * Fills up the input ringbuffer by calling the input callback.\n *\n * Does nothing if there are at least 32 bytes present after current position.\n *\n * Returns 0 if either:\n *  - the input callback returned an error, or\n *  - there is no more input and the position is past the end of the stream.\n *\n * After encountering the end of the input stream, 32 additional zero bytes are\n * copied to the ringbuffer, therefore it is safe to call this function after\n * every 32 bytes of input is read.\n */\nBrotliBitReader.prototype.readMoreInput = function() {\n  if (this.bit_end_pos_ > 256) {\n    // return\n  } else if (this.eos_) {\n    if (this.bit_pos_ > this.bit_end_pos_)\n      throw new Error('Unexpected end of input ' + this.bit_pos_ + ' ' + this.bit_end_pos_)\n  } else {\n    const dst = this.buf_ptr_\n    const bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE)\n    if (bytes_read < 0) {\n      throw new Error('Unexpected end of input')\n    }\n\n    if (bytes_read < BROTLI_READ_SIZE) {\n      this.eos_ = 1\n      /* Store 32 bytes of zero after the stream end. */\n      for (let p = 0; p < 32; p++)\n        this.buf_[dst + bytes_read + p] = 0\n    }\n\n    if (dst === 0) {\n      /* Copy the head of the ringbuffer to the slack region. */\n      for (let p = 0; p < 32; p++)\n        this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p]\n\n      this.buf_ptr_ = BROTLI_READ_SIZE\n    } else {\n      this.buf_ptr_ = 0\n    }\n\n    this.bit_end_pos_ += bytes_read << 3\n  }\n}\n\n/* Guarantees that there are at least 24 bits in the buffer. */\nBrotliBitReader.prototype.fillBitWindow = function() {\n  while (this.bit_pos_ >= 8) {\n    this.val_ >>>= 8\n    this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24\n    this.pos_++\n    this.bit_pos_ = this.bit_pos_ - 8 >>> 0\n    this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0\n  }\n}\n\n/**\n * Reads the specified number of bits from Read Buffer.\n *\n * @param {number} n_bits\n * @returns {number}\n */\nBrotliBitReader.prototype.readBits = function(n_bits) {\n  if (32 - this.bit_pos_ < n_bits) this.fillBitWindow()\n  const val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits]\n  this.bit_pos_ += n_bits\n  return val\n}\n\nexport default BrotliBitReader\n","/* Copyright 2013 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n   Lookup table to map the previous two bytes to a context id.\n\n   There are four different context modeling modes defined here:\n     CONTEXT_LSB6: context id is the least significant 6 bits of the last byte,\n     CONTEXT_MSB6: context id is the most significant 6 bits of the last byte,\n     CONTEXT_UTF8: second-order context model tuned for UTF8-encoded text,\n     CONTEXT_SIGNED: second-order context model tuned for signed integers.\n\n   The context id for the UTF8 context model is calculated as follows. If p1\n   and p2 are the previous two bytes, we calcualte the context as\n\n     context = kContextLookup[p1] | kContextLookup[p2 + 256].\n\n   If the previous two bytes are ASCII characters (i.e. < 128), this will be\n   equivalent to\n\n     context = 4 * context1(p1) + context2(p2),\n\n   where context1 is based on the previous byte in the following way:\n\n     0  : non-ASCII control\n     1  : \\t, \\n, \\r\n     2  : space\n     3  : other punctuation\n     4  : \" '\n     5  : %\n     6  : ( < [ {\n     7  : ) > ] }\n     8  : , ; :\n     9  : .\n     10 : =\n     11 : number\n     12 : upper-case vowel\n     13 : upper-case consonant\n     14 : lower-case vowel\n     15 : lower-case consonant\n\n   and context2 is based on the second last byte:\n\n     0 : control, space\n     1 : punctuation\n     2 : upper-case letter, number\n     3 : lower-case letter\n\n   If the last byte is ASCII, and the second last byte is not (in a valid UTF8\n   stream it will be a continuation byte, value between 128 and 191), the\n   context is the same as if the second last byte was an ASCII control or space.\n\n   If the last byte is a UTF8 lead byte (value >= 192), then the next byte will\n   be a continuation byte and the context id is 2 or 3 depending on the LSB of\n   the last byte and to a lesser extent on the second last byte if it is ASCII.\n\n   If the last byte is a UTF8 continuation byte, the second last byte can be:\n     - continuation byte: the next byte is probably ASCII or lead byte (assuming\n       4-byte UTF8 characters are rare) and the context id is 0 or 1.\n     - lead byte (192 - 207): next byte is ASCII or lead byte, context is 0 or 1\n     - lead byte (208 - 255): next byte is continuation byte, context is 2 or 3\n\n   The possible value combinations of the previous two bytes, the range of\n   context ids and the type of the next byte is summarized in the table below:\n\n   |--------\\-----------------------------------------------------------------|\n   |         \\                         Last byte                              |\n   | Second   \\---------------------------------------------------------------|\n   | last byte \\    ASCII            |   cont. byte        |   lead byte      |\n   |            \\   (0-127)          |   (128-191)         |   (192-)         |\n   |=============|===================|=====================|==================|\n   |  ASCII      | next: ASCII/lead  |  not valid          |  next: cont.     |\n   |  (0-127)    | context: 4 - 63   |                     |  context: 2 - 3  |\n   |-------------|-------------------|---------------------|------------------|\n   |  cont. byte | next: ASCII/lead  |  next: ASCII/lead   |  next: cont.     |\n   |  (128-191)  | context: 4 - 63   |  context: 0 - 1     |  context: 2 - 3  |\n   |-------------|-------------------|---------------------|------------------|\n   |  lead byte  | not valid         |  next: ASCII/lead   |  not valid       |\n   |  (192-207)  |                   |  context: 0 - 1     |                  |\n   |-------------|-------------------|---------------------|------------------|\n   |  lead byte  | not valid         |  next: cont.        |  not valid       |\n   |  (208-)     |                   |  context: 2 - 3     |                  |\n   |-------------|-------------------|---------------------|------------------|\n\n   The context id for the signed context mode is calculated as:\n\n     context = (kContextLookup[512 + p1] << 3) | kContextLookup[512 + p2].\n\n   For any context modeling modes, the context ids can be calculated by |-ing\n   together two lookups from one table using context model dependent offsets:\n\n     context = kContextLookup[offset1 + p1] | kContextLookup[offset2 + p2].\n\n   where offset1 and offset2 are dependent on the context mode.\n*/\n\n/* Common context lookup table for all context modes. */\nexport const lookup = new Uint8Array([\n  /* CONTEXT_UTF8, last byte. */\n  /* ASCII range. */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  8, 12, 16, 12, 12, 20, 12, 16, 24, 28, 12, 12, 32, 12, 36, 12,\n  44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 32, 32, 24, 40, 28, 12,\n  12, 48, 52, 52, 52, 48, 52, 52, 52, 48, 52, 52, 52, 52, 52, 48,\n  52, 52, 52, 52, 52, 48, 52, 52, 52, 52, 52, 24, 12, 28, 12, 12,\n  12, 56, 60, 60, 60, 56, 60, 60, 60, 56, 60, 60, 60, 60, 60, 56,\n  60, 60, 60, 60, 60, 56, 60, 60, 60, 60, 60, 24, 12, 28, 12, 0,\n  /* UTF8 continuation byte range. */\n  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n  0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1,\n  /* UTF8 lead byte range. */\n  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n  2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3, 2, 3,\n  /* CONTEXT_UTF8 second last byte. */\n  /* ASCII range. */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,\n  1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1,\n  1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 0,\n  /* UTF8 continuation byte range. */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  /* UTF8 lead byte range. */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  /* CONTEXT_SIGNED, second last byte. */\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7,\n  /* CONTEXT_SIGNED, last byte, same as the above values shifted by 3 bits. */\n  0, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,\n  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n  32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,\n  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n  40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,\n  48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 56,\n  /* CONTEXT_LSB6, last byte. */\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,\n  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,\n  /* CONTEXT_MSB6, last byte. */\n  0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3,\n  4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7,\n  8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11,\n  12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15,\n  16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19,\n  20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23,\n  24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27,\n  28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31, 31, 31,\n  32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35, 35, 35,\n  36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39, 39, 39,\n  40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 43, 43, 43, 43,\n  44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47, 47, 47, 47,\n  48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51, 51, 51, 51,\n  52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55, 55, 55, 55,\n  56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59, 59, 59, 59,\n  60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63, 63, 63, 63,\n  /* CONTEXT_{M,L}SB6, second last byte, */\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n])\n\nexport const lookupOffsets = new Uint16Array([\n  /* CONTEXT_LSB6 */\n  1024, 1536,\n  /* CONTEXT_MSB6 */\n  1280, 1536,\n  /* CONTEXT_UTF8 */\n  0, 256,\n  /* CONTEXT_SIGNED */\n  768, 512,\n])\n","\nconst kDefaultCodeLength = 8\n\nconst HUFFMAN_TABLE_BITS = 8\nconst HUFFMAN_TABLE_MASK = 0xff\n\nconst CODE_LENGTH_CODES = 18\nconst kCodeLengthCodeOrder = new Uint8Array([\n  1, 2, 3, 4, 0, 5, 17, 6, 16, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n])\n\n/**\n * @param {number} bits\n * @param {number} value\n */\nexport function HuffmanCode(bits, value) {\n  this.bits = bits /* number of bits used for this symbol */\n  this.value = value /* symbol value or table offset */\n}\n\nconst kCodeLengthRepeatCode = 16\nconst MAX_LENGTH = 15\n\n/**\n * Returns reverse(reverse(key, len) + 1, len), where reverse(key, len) is the\n * bit-wise reversal of the len least significant bits of key.\n * @param {number} key\n * @param {number} len\n * @returns {number}\n */\nfunction getNextKey(key, len) {\n  let step = 1 << len - 1\n  while (key & step) {\n    step >>= 1\n  }\n  return (key & step - 1) + step\n}\n\n/**\n * Stores code in table[0], table[step], table[2*step], ..., table[end]\n * Assumes that end is an integer multiple of step\n * @param {HuffmanCode[]} table\n * @param {number} i\n * @param {number} step\n * @param {number} end\n * @param {HuffmanCode} code\n */\nfunction replicateValue(table, i, step, end, code) {\n  do {\n    end -= step\n    table[i + end] = new HuffmanCode(code.bits, code.value)\n  } while (end > 0)\n}\n\n/**\n * Returns the table width of the next 2nd level table. count is the histogram\n * of bit lengths for the remaining symbols, len is the code length of the next\n * processed symbol\n * @param {Int32Array} count\n * @param {number} len\n * @param {number} root_bits\n * @returns {number}\n */\nfunction nextTableBitSize(count, len, root_bits) {\n  let left = 1 << len - root_bits\n  while (len < MAX_LENGTH) {\n    left -= count[len]\n    if (left <= 0) break\n    ++len\n    left <<= 1\n  }\n  return len - root_bits\n}\n\n/**\n * @param {HuffmanCode[]} root_table\n * @param {number} table\n * @param {number} root_bits\n * @param {Uint8Array} code_lengths\n * @param {number} code_lengths_size\n * @returns {number}\n */\nexport function buildHuffmanTable(root_table, table, root_bits, code_lengths, code_lengths_size) {\n  const start_table = table\n  const count = new Int32Array(MAX_LENGTH + 1) /* number of codes of each length */\n  const offset = new Int32Array(MAX_LENGTH + 1) /* offsets in sorted table for each length */\n  const sorted = new Int32Array(code_lengths_size) /* symbols sorted by code length */\n\n  /* build histogram of code lengths */\n  for (let i = 0; i < code_lengths_size; i++) {\n    count[code_lengths[i]]++\n  }\n\n  /* generate offsets into sorted symbol table by code length */\n  offset[1] = 0\n  for (let i = 1; i < MAX_LENGTH; i++) {\n    offset[i + 1] = offset[i] + count[i]\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (let i = 0; i < code_lengths_size; i++) {\n    if (code_lengths[i] !== 0) {\n      sorted[offset[code_lengths[i]]++] = i\n    }\n  }\n\n  let table_bits = root_bits // key length of current table\n  let table_size = 1 << table_bits\n  let total_size = table_size // sum of root table size and 2nd level table sizes\n\n  /* special case code with only one value */\n  if (offset[MAX_LENGTH] === 1) {\n    for (let key = 0; key < total_size; ++key) {\n      root_table[table + key] = new HuffmanCode(0, sorted[0] & 0xffff)\n    }\n\n    return total_size\n  }\n\n  /* fill in root table */\n  let key = 0 // reversed prefix code\n  let symbol = 0 // symbol index in original or sorted table\n  for (let len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {\n    for (; count[len] > 0; --count[len]) {\n      const code = new HuffmanCode(len & 0xff, sorted[symbol++] & 0xffff)\n      replicateValue(root_table, table + key, step, table_size, code)\n      key = getNextKey(key, len)\n    }\n  }\n\n  /* fill in 2nd level tables and add pointers to root table */\n  const mask = total_size - 1\n  let low = -1 // low bits for current root entry\n  for (let len = root_bits + 1, step = 2; len <= MAX_LENGTH; ++len, step <<= 1) {\n    for (; count[len] > 0; --count[len]) {\n      if ((key & mask) !== low) {\n        table += table_size\n        table_bits = nextTableBitSize(count, len, root_bits)\n        table_size = 1 << table_bits\n        total_size += table_size\n        low = key & mask\n        root_table[start_table + low] = new HuffmanCode(table_bits + root_bits & 0xff, table - start_table - low & 0xffff)\n      }\n      const code = new HuffmanCode(len - root_bits & 0xff, sorted[symbol++] & 0xffff)\n      replicateValue(root_table, table + (key >> root_bits), step, table_size, code)\n      key = getNextKey(key, len)\n    }\n  }\n\n  return total_size\n}\n\n/**\n * @typedef {import('./brotliBitReader.js').default} BrotliBitReader\n * @param {number} alphabet_size\n * @param {HuffmanCode[]} tables\n * @param {number} table\n * @param {BrotliBitReader} br\n * @returns {number}\n */\nexport function readHuffmanCode(alphabet_size, tables, table, br) {\n  const code_lengths = new Uint8Array(alphabet_size)\n\n  br.readMoreInput()\n\n  /* simple_code_or_skip is used as follows:\n     1 for simple code;\n     0 for no skipping, 2 skips 2 code lengths, 3 skips 3 code lengths */\n  const simple_code_or_skip = br.readBits(2)\n  if (simple_code_or_skip === 1) {\n    /* Read symbols, codes & code lengths directly. */\n    let max_bits_counter = alphabet_size - 1\n    let max_bits = 0\n    const symbols = new Int32Array(4)\n    const num_symbols = br.readBits(2) + 1\n    while (max_bits_counter) {\n      max_bits_counter >>= 1\n      max_bits++\n    }\n\n    for (let i = 0; i < num_symbols; i++) {\n      symbols[i] = br.readBits(max_bits) % alphabet_size\n      code_lengths[symbols[i]] = 2\n    }\n    code_lengths[symbols[0]] = 1\n    switch (num_symbols) {\n    case 1:\n      break\n    case 3:\n      if (symbols[0] === symbols[1] ||\n            symbols[0] === symbols[2] ||\n            symbols[1] === symbols[2]) {\n        throw new Error('[ReadHuffmanCode] invalid symbols')\n      }\n      break\n    case 2:\n      if (symbols[0] === symbols[1]) {\n        throw new Error('[ReadHuffmanCode] invalid symbols')\n      }\n\n      code_lengths[symbols[1]] = 1\n      break\n    case 4:\n      if (symbols[0] === symbols[1] ||\n            symbols[0] === symbols[2] ||\n            symbols[0] === symbols[3] ||\n            symbols[1] === symbols[2] ||\n            symbols[1] === symbols[3] ||\n            symbols[2] === symbols[3]) {\n        throw new Error('[ReadHuffmanCode] invalid symbols')\n      }\n\n      if (br.readBits(1)) {\n        code_lengths[symbols[2]] = 3\n        code_lengths[symbols[3]] = 3\n      } else {\n        code_lengths[symbols[0]] = 2\n      }\n      break\n    }\n  } else { /* Decode Huffman-coded code lengths. */\n    const code_length_code_lengths = new Uint8Array(CODE_LENGTH_CODES)\n    let space = 32\n    let num_codes = 0\n    /* Static Huffman code for the code length code lengths */\n    const huff = [\n      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(3, 2),\n      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(4, 1),\n      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(3, 2),\n      new HuffmanCode(2, 0), new HuffmanCode(2, 4), new HuffmanCode(2, 3), new HuffmanCode(4, 5),\n    ]\n    for (let i = simple_code_or_skip; i < CODE_LENGTH_CODES && space > 0; i++) {\n      const code_len_idx = kCodeLengthCodeOrder[i]\n      let p = 0\n      br.fillBitWindow()\n      p += br.val_ >>> br.bit_pos_ & 15\n      br.bit_pos_ += huff[p].bits\n      const v = huff[p].value\n      code_length_code_lengths[code_len_idx] = v\n      if (v !== 0) {\n        space -= 32 >> v\n        num_codes++\n      }\n    }\n\n    if (!(num_codes === 1 || space === 0))\n      throw new Error('[ReadHuffmanCode] invalid num_codes or space')\n\n    readHuffmanCodeLengths(code_length_code_lengths, alphabet_size, code_lengths, br)\n  }\n\n  const table_size = buildHuffmanTable(tables, table, HUFFMAN_TABLE_BITS, code_lengths, alphabet_size)\n  if (!table_size) throw new Error('brotli BuildHuffmanTable failed')\n  return table_size\n}\n\n/**\n * Decodes the next Huffman code from bit-stream.\n * @param {HuffmanCode[]} table\n * @param {number} index\n * @param {BrotliBitReader} br\n * @returns {number}\n\n */\nexport function readSymbol(table, index, br) {\n  br.fillBitWindow()\n  index += br.val_ >>> br.bit_pos_ & HUFFMAN_TABLE_MASK\n  const nbits = table[index].bits - HUFFMAN_TABLE_BITS\n  if (nbits > 0) {\n    br.bit_pos_ += HUFFMAN_TABLE_BITS\n    index += table[index].value\n    index += br.val_ >>> br.bit_pos_ & (1 << nbits) - 1\n  }\n  br.bit_pos_ += table[index].bits\n  return table[index].value\n}\n\n/**\n * @param {Uint8Array} code_length_code_lengths\n * @param {number} num_symbols\n * @param {Uint8Array} code_lengths\n * @param {BrotliBitReader} br\n */\nfunction readHuffmanCodeLengths(code_length_code_lengths, num_symbols, code_lengths, br) {\n  let symbol = 0\n  let prev_code_len = kDefaultCodeLength\n  let repeat = 0\n  let repeat_code_len = 0\n  let space = 32768\n\n  const table = []\n  for (let i = 0; i < 32; i++)\n    table.push(new HuffmanCode(0, 0))\n\n  buildHuffmanTable(table, 0, 5, code_length_code_lengths, CODE_LENGTH_CODES)\n\n  while (symbol < num_symbols && space > 0) {\n    let p = 0\n\n    br.readMoreInput()\n    br.fillBitWindow()\n    p += br.val_ >>> br.bit_pos_ & 31\n    br.bit_pos_ += table[p].bits\n    const code_len = table[p].value & 0xff\n    if (code_len < kCodeLengthRepeatCode) {\n      repeat = 0\n      code_lengths[symbol++] = code_len\n      if (code_len !== 0) {\n        prev_code_len = code_len\n        space -= 32768 >> code_len\n      }\n    } else {\n      const extra_bits = code_len - 14\n      let new_len = 0\n      if (code_len === kCodeLengthRepeatCode) {\n        new_len = prev_code_len\n      }\n      if (repeat_code_len !== new_len) {\n        repeat = 0\n        repeat_code_len = new_len\n      }\n      const old_repeat = repeat\n      if (repeat > 0) {\n        repeat -= 2\n        repeat <<= extra_bits\n      }\n      repeat += br.readBits(extra_bits) + 3\n      const repeat_delta = repeat - old_repeat\n      if (symbol + repeat_delta > num_symbols) {\n        throw new Error('[ReadHuffmanCodeLengths] symbol + repeat_delta > num_symbols')\n      }\n\n      for (let x = 0; x < repeat_delta; x++)\n        code_lengths[symbol + x] = repeat_code_len\n\n      symbol += repeat_delta\n\n      if (repeat_code_len !== 0) {\n        space -= repeat_delta << 15 - repeat_code_len\n      }\n    }\n  }\n  if (space !== 0) {\n    throw new Error('[ReadHuffmanCodeLengths] space = ' + space)\n  }\n\n  for (; symbol < num_symbols; symbol++)\n    code_lengths[symbol] = 0\n}\n","/* Copyright 2013 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n   Lookup tables to map prefix codes to value ranges. This is used during\n   decoding of the block lengths, literal insertion lengths and copy lengths.\n*/\n\n/**\n * Represents the range of values belonging to a prefix code:\n * [offset, offset + 2^nbits)\n * @param {number} offset\n * @param {number} nbits\n */\nfunction PrefixCodeRange(offset, nbits) {\n  this.offset = offset\n  this.nbits = nbits\n}\n\nexport const kBlockLengthPrefixCode = [\n  new PrefixCodeRange(1, 2), new PrefixCodeRange(5, 2), new PrefixCodeRange(9, 2), new PrefixCodeRange(13, 2),\n  new PrefixCodeRange(17, 3), new PrefixCodeRange(25, 3), new PrefixCodeRange(33, 3), new PrefixCodeRange(41, 3),\n  new PrefixCodeRange(49, 4), new PrefixCodeRange(65, 4), new PrefixCodeRange(81, 4), new PrefixCodeRange(97, 4),\n  new PrefixCodeRange(113, 5), new PrefixCodeRange(145, 5), new PrefixCodeRange(177, 5), new PrefixCodeRange(209, 5),\n  new PrefixCodeRange(241, 6), new PrefixCodeRange(305, 6), new PrefixCodeRange(369, 7), new PrefixCodeRange(497, 8),\n  new PrefixCodeRange(753, 9), new PrefixCodeRange(1265, 10), new PrefixCodeRange(2289, 11), new PrefixCodeRange(4337, 12),\n  new PrefixCodeRange(8433, 13), new PrefixCodeRange(16625, 24),\n]\n\nexport const kInsertLengthPrefixCode = [\n  new PrefixCodeRange(0, 0), new PrefixCodeRange(1, 0), new PrefixCodeRange(2, 0), new PrefixCodeRange(3, 0),\n  new PrefixCodeRange(4, 0), new PrefixCodeRange(5, 0), new PrefixCodeRange(6, 1), new PrefixCodeRange(8, 1),\n  new PrefixCodeRange(10, 2), new PrefixCodeRange(14, 2), new PrefixCodeRange(18, 3), new PrefixCodeRange(26, 3),\n  new PrefixCodeRange(34, 4), new PrefixCodeRange(50, 4), new PrefixCodeRange(66, 5), new PrefixCodeRange(98, 5),\n  new PrefixCodeRange(130, 6), new PrefixCodeRange(194, 7), new PrefixCodeRange(322, 8), new PrefixCodeRange(578, 9),\n  new PrefixCodeRange(1090, 10), new PrefixCodeRange(2114, 12), new PrefixCodeRange(6210, 14), new PrefixCodeRange(22594, 24),\n]\n\nexport const kCopyLengthPrefixCode = [\n  new PrefixCodeRange(2, 0), new PrefixCodeRange(3, 0), new PrefixCodeRange(4, 0), new PrefixCodeRange(5, 0),\n  new PrefixCodeRange(6, 0), new PrefixCodeRange(7, 0), new PrefixCodeRange(8, 0), new PrefixCodeRange(9, 0),\n  new PrefixCodeRange(10, 1), new PrefixCodeRange(12, 1), new PrefixCodeRange(14, 2), new PrefixCodeRange(18, 2),\n  new PrefixCodeRange(22, 3), new PrefixCodeRange(30, 3), new PrefixCodeRange(38, 4), new PrefixCodeRange(54, 4),\n  new PrefixCodeRange(70, 5), new PrefixCodeRange(102, 5), new PrefixCodeRange(134, 6), new PrefixCodeRange(198, 7),\n  new PrefixCodeRange(326, 8), new PrefixCodeRange(582, 9), new PrefixCodeRange(1094, 10), new PrefixCodeRange(2118, 24),\n]\n\nexport const kInsertRangeLut = [\n  0, 0, 8, 8, 0, 16, 8, 16, 16,\n]\n\nexport const kCopyRangeLut = [\n  0, 8, 0, 8, 16, 0, 16, 8, 16,\n]\n","/**\n * @param {Uint8Array} buffer\n */\nexport function BrotliInput(buffer) {\n  this.buffer = buffer\n  this.pos = 0\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {number} i\n * @param {number} count\n * @returns {number}\n */\nBrotliInput.prototype.read = function(buf, i, count) {\n  if (this.pos + count > this.buffer.length) {\n    count = this.buffer.length - this.pos\n  }\n\n  for (let p = 0; p < count; p++)\n    buf[i + p] = this.buffer[this.pos + p]\n\n  this.pos += count\n  return count\n}\n\n/**\n * @param {Uint8Array} buf\n */\nexport function BrotliOutput(buf) {\n  this.buffer = buf\n  this.pos = 0\n}\n\n/**\n * @param {Uint8Array} buf\n * @param {number} count\n * @returns {number}\n */\nBrotliOutput.prototype.write = function(buf, count) {\n  if (this.pos + count > this.buffer.length) throw new Error('brotli output buffer is not large enough')\n\n  this.buffer.set(buf.subarray(0, count), this.pos)\n  this.pos += count\n  return count\n}\n","// Adapted from https://github.com/101arrowz/fflate Copyright (c) 2023 Arjun Barrett\n// https://tools.ietf.org/html/rfc1951\n\n// fixed length extra bits\nconst fixedLengthExtraBits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0])\nconst fixedDistanceExtraBits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0])\nconst codeLengthIndexMap = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])\n\n/**\n * get base, reverse index map from extra bits\n * @param {Uint8Array} eb\n * @param {number} start\n * @returns {{base: Uint16Array, rev: Int32Array}}\n */\nfunction freb(eb, start) {\n  const base = new Uint16Array(31)\n  for (let i = 0; i < 31; i++) {\n    base[i] = start += 1 << eb[i - 1]\n  }\n  // numbers here are max 18 bits\n  const rev = new Int32Array(base[30])\n  for (let i = 1; i < 30; i++) {\n    for (let j = base[i]; j < base[i + 1]; ++j) {\n      rev[j] = j - base[i] << 5 | i\n    }\n  }\n  return { base, rev }\n}\n\nconst { base: fl, rev: revfl } = freb(fixedLengthExtraBits, 2)\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258\nrevfl[258] = 28\nconst { base: fd } = freb(fixedDistanceExtraBits, 0)\n\n// map of value to reverse (assuming 16 bits)\nconst rev = new Uint16Array(32768)\nfor (let i = 0; i < 32768; i++) {\n  // reverse table algorithm from SO\n  let x = (i & 0xAAAA) >> 1 | (i & 0x5555) << 1\n  x = (x & 0xCCCC) >> 2 | (x & 0x3333) << 2\n  x = (x & 0xF0F0) >> 4 | (x & 0x0F0F) << 4\n  rev[i] = ((x & 0xFF00) >> 8 | (x & 0x00FF) << 8) >> 1\n}\n\n/**\n * create huffman tree from Uint8Array \"map\": index -> code length for code index\n * maxBits must be at most 15\n * @param {Uint8Array} cd\n * @param {number} maxBits\n * @param {0 | 1} r\n * @returns {Uint16Array}\n */\nfunction huffMap(cd, maxBits, r) {\n  // u16 \"map\": index -> # of codes with bit length = index\n  const l = new Uint16Array(maxBits)\n  // length of cd must be 288 (total # of codes)\n  for (let i = 0; i < cd.length; i++) {\n    if (cd[i]) ++l[cd[i] - 1]\n  }\n  // u16 \"map\": index -> minimum code for bit length = index\n  const le = new Uint16Array(maxBits)\n  for (let i = 1; i < maxBits; i++) {\n    le[i] = le[i - 1] + l[i - 1] << 1\n  }\n  let co\n  if (r) {\n    // u16 \"map\": index -> number of actual bits, symbol for code\n    co = new Uint16Array(1 << maxBits)\n    // bits to remove for reverser\n    const rvb = 15 - maxBits\n    for (let i = 0; i < cd.length; i++) {\n      // ignore 0 lengths\n      if (cd[i]) {\n        // num encoding both symbol and bits read\n        const sv = i << 4 | cd[i]\n        const freeBits = maxBits - cd[i]\n        let startValue = le[cd[i] - 1]++ << freeBits\n        for (const endValue = startValue | (1 << freeBits) - 1; startValue <= endValue; startValue++) {\n          // every 16 bit value starting with the code yields the same result\n          co[rev[startValue] >> rvb] = sv\n        }\n      }\n    }\n  } else {\n    co = new Uint16Array(cd.length)\n    for (let i = 0; i < cd.length; i++) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i]\n      }\n    }\n  }\n  return co\n}\n\n// construct huffman trees\nconst fixedLengthTree = new Uint8Array(288)\nfor (let i = 0; i < 144; i++) fixedLengthTree[i] = 8\nfor (let i = 144; i < 256; i++) fixedLengthTree[i] = 9\nfor (let i = 256; i < 280; i++) fixedLengthTree[i] = 7\nfor (let i = 280; i < 288; i++) fixedLengthTree[i] = 8\nconst fixedDistanceTree = new Uint8Array(32)\nfor (let i = 0; i < 32; i++) fixedDistanceTree[i] = 5\nconst fixedLengthMap = /*#__PURE__*/ huffMap(fixedLengthTree, 9, 1)\nconst fixedDistanceMap = /*#__PURE__*/ huffMap(fixedDistanceTree, 5, 1)\n\n/**\n * find max of array\n * @param {Uint8Array | number[]} a\n * @returns {number}\n */\nfunction max(a) {\n  let m = a[0]\n  for (let i = 1; i < a.length; i++) {\n    if (a[i] > m) m = a[i]\n  }\n  return m\n}\n\n/**\n * read d, starting at bit p and mask with m\n * @param {Uint8Array} input\n * @param {number} pos\n * @param {number} mask\n * @returns {number}\n */\nfunction bits(input, pos, mask) {\n  const o = pos / 8 | 0\n  return (input[o] | input[o + 1] << 8) >> (pos & 7) & mask\n}\n\n/**\n * read d, starting at bit p continuing for at least 16 bits\n * @param {Uint8Array} d\n * @param {number} p\n * @returns {number}\n */\nfunction bits16(d, p) {\n  const o = p / 8 | 0\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7)\n}\n\n/**\n * get end of byte\n * @param {number} p\n * @returns {number}\n */\nfunction shft(p) {\n  return (p + 7) / 8 | 0\n}\n\n/**\n * return start of gzip payload index\n * @param {Uint8Array} input\n * @param {number} i inputIndex\n * @returns {number}\n */\nfunction gzipStart(input, i) {\n  if (input[i++] !== 31 || input[i++] !== 139 || input[i++] !== 8) throw new Error('invalid gzip data')\n  const flag = input[i++]\n  i += 6\n  if (flag & 4) i += (input[i + 10] | input[i + 11] << 8) + 2\n  for (let zs = (flag >> 3 & 1) + (flag >> 4 & 1); zs > 0; zs -= Number(!input[i++]));\n  return i + (flag & 2)\n}\n\n/**\n * GZip decompression\n * @param {Uint8Array} input\n * @param {Uint8Array} out\n * @param {number} [inputIndex]\n * @param {number} [outputIndex]\n */\nexport function gunzip(input, out, inputIndex = 0, outputIndex = 0) {\n  if (!(input.length - inputIndex)) return\n  const payloadStart = gzipStart(input, inputIndex)\n  if (payloadStart === input.length - 8) return\n  if (payloadStart > input.length - 8) throw new Error('unexpected EOF')\n  let pos = payloadStart * 8 // position in bits\n  let final = 0 // last chunk?\n  let lengthBits = 0\n  let distBits = 0\n  let lmap\n  let dmap\n  const totalBits = input.length * 8\n  do {\n    if (!lmap) {\n      // final chunk is next?\n      final = bits(input, pos, 1)\n      const type = bits(input, pos + 1, 3)\n      pos += 3\n      if (!type) {\n        // no compression\n        // go to end of byte boundary\n        const s = shft(pos) + 4\n        const l = input[s - 4] | input[s - 3] << 8\n        const t = s + l\n        if (t > input.length) throw new Error('unexpected EOF')\n        // copy uncompressed data\n        out.set(input.subarray(s, t), outputIndex)\n        outputIndex += l\n        pos = t * 8\n        continue\n      } else if (type === 1) {\n        // fixed huffman\n        lmap = fixedLengthMap\n        dmap = fixedDistanceMap\n        lengthBits = 9\n        distBits = 5\n      } else if (type === 2) {\n        // dynamic huffman\n        const hLiteral = bits(input, pos, 31) + 257\n        const hcLengths = bits(input, pos + 10, 15) + 4\n        const tl = hLiteral + bits(input, pos + 5, 31) + 1\n        pos += 14\n        // length+distance tree\n        const lengthDistanceTree = new Uint8Array(tl)\n        const codeLengthTree = new Uint8Array(19)\n        for (let i = 0; i < hcLengths; ++i) {\n          // use index map to get real code\n          codeLengthTree[codeLengthIndexMap[i]] = bits(input, pos + i * 3, 7)\n        }\n        pos += hcLengths * 3\n        const codeLengthBits = max(codeLengthTree)\n        const clbMask = (1 << codeLengthBits) - 1\n        const codeLengthMap = huffMap(codeLengthTree, codeLengthBits, 1)\n        for (let i = 0; i < tl;) {\n          const r = codeLengthMap[bits(input, pos, clbMask)]\n          // bits read\n          pos += r & 15\n          const symbol = r >> 4\n          // code length to copy\n          if (symbol < 16) {\n            lengthDistanceTree[i++] = symbol\n          } else {\n            let copy = 0\n            let n = 0 // count\n            if (symbol === 16) {\n              n = 3 + bits(input, pos, 3)\n              pos += 2\n              copy = lengthDistanceTree[i - 1]\n            } else if (symbol === 17) {\n              n = 3 + bits(input, pos, 7)\n              pos += 3\n            } else if (symbol === 18) {\n              n = 11 + bits(input, pos, 127)\n              pos += 7\n            }\n            while (n--) lengthDistanceTree[i++] = copy\n          }\n        }\n        const lengthTree = lengthDistanceTree.subarray(0, hLiteral)\n        const distanceTree = lengthDistanceTree.subarray(hLiteral)\n        // max length bits\n        lengthBits = max(lengthTree)\n        // max dist bits\n        distBits = max(distanceTree)\n        lmap = huffMap(lengthTree, lengthBits, 1)\n        dmap = huffMap(distanceTree, distBits, 1)\n      } else throw new Error('invalid block type')\n      if (pos > totalBits) throw new Error('unexpected EOF')\n    }\n    const lms = (1 << lengthBits) - 1\n    const dms = (1 << distBits) - 1\n    let lpos = pos\n    for (;; lpos = pos) {\n      // bits read, code\n      const code = lmap[bits16(input, pos) & lms]\n      const sym = code >> 4\n      pos += code & 15\n      if (pos > totalBits) throw new Error('unexpected EOF')\n      if (!code) throw new Error('invalid length/literal')\n      if (sym < 256) out[outputIndex++] = sym\n      else if (sym === 256) {\n        lpos = pos\n        lmap = undefined\n        break\n      } else {\n        let add = sym - 254\n        // no extra bits needed if less\n        if (sym > 264) {\n          const index = sym - 257\n          const b = fixedLengthExtraBits[index]\n          add = bits(input, pos, (1 << b) - 1) + fl[index]\n          pos += b\n        }\n        // dist\n        if (!dmap) throw new Error('invalid distance map')\n        const d = dmap[bits16(input, pos) & dms]\n        const dsym = d >> 4\n        if (!d) throw new Error('invalid distance')\n        pos += d & 15\n        let dt = fd[dsym]\n        if (dsym > 3) {\n          const b = fixedDistanceExtraBits[dsym]\n          dt += bits16(input, pos) & (1 << b) - 1\n          pos += b\n        }\n        if (pos > totalBits) throw new Error('unexpected EOF')\n        const end = outputIndex + add\n        if (outputIndex < dt) throw new Error('unexpected dictionary case')\n        for (; outputIndex < end; outputIndex++) out[outputIndex] = out[outputIndex - dt]\n      }\n    }\n    pos = lpos\n    if (lmap) final = 1\n  } while (!final)\n\n  if (outputIndex < out.length) {\n    // multiple gzip blocks\n    const nextBlock = Math.ceil(pos / 8) + 8 // 8 byte gzip footer\n    gunzip(input, out, nextBlock, outputIndex)\n  }\n}\n","/* Copyright 2013 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n   Collection of static dictionary words.\n*/\n\nimport { gunzip } from './gzip.js'\n\nconst dictionaryGz64 = `\n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\nXH/9kw/e+uTa937x6JlPn7j+86ee/PnpG7e/+yefvfzM7ddetBc/+977t3/83mcf/PknV4/fPvfq7e+/\n+cm7P/z0/F/84uwzn7154uc/PvHp69//9I9/+Ml7P7r9/IXbz57/9Pqf3r7y5GdvX/vs+KlPn/7LT0+9\n8en505+dP/PZ+eufPnP99jtvffripU+vnrz9J+duf/+GtefTZ37wyfU37JVPT7/+6bnXfv79lz678vTt\nv3jV/v25Pc73HsfFP3j59ok3rc0BJ2xs7t08Zz7DAKYbJnK5UgK2jQzJmCC4augYsG4CCZp91RPMCbYW\n8rY2w92psSU9JsJr5eZ15HTJPhdaiJXaqRIg7wbBWKEHHX5adwdhvA2PhJOVkIQAXgHUR5kUgqH6MGbJ\nTde53MIZEy6yqT3ANRAzmtC71THhd+I63zxX1ps3X4Z9ESjZchjwqiFzLkBagm7Pm5oZd/Ona2Dpo0SW\nY7IEIhOZVrcgTg4z9eUeatU7/9w2XQdQNR4xq0vb/pGqKBvnbA8aB2VF1VrreWvMzZdXR+KVEBjpfVg7\nksxeQS+zV7Fw2NR4Ckd5E65GGF/Zc94LlRfsBWghULUSXnoJFac+6hn2H7HmV49EANm8/B5nSxkwvsbN\nMkyBIZCVfSDxXmYmA5BcYsTQZk6SrdK/FWjBJmCS0fODJopqn2RJ7A+85DaKjp9kYWwVBb/Kf1/lu5f5\n1gV+7ImoRK4i5Sf+9vSf+1v4/Bv89zVW7L4W11FV8mv88HNxneNshm76GptxJr5+ultDqWKw2ngJcDTp\nwt++epL1y8/wM+f5+2n+/jN+/QKLo1/li6ejSRejbLnu/njc4kJUDb8Sb1lLXuArF3k7Nen5uJeKlL/B\neurHvan45Ud8imd4R/XYxahQ/gILnD8Vdcpf4/9Oq846r6BOuBL1zk/xuz/gTc/FXX4Q5d7Vkxeyeu0a\nuKeiSDwHzvvZOuqElznHWy95b+MBv8NC7M9HJ5yKe/0gCrefZm+kausvRUed5IfVnu/FTc9Hj6nlN2LQ\n7c+no0r9j+Je34su0gVVEv4Dvqjevsi+0nx4IwZaj6O5eiN69Tg74Q027wxbq68/EQ17HK97XXnNZ81V\njc5TbO25KGN/IZ7iRZ8q3s/n/bnw7ln++2I84Ktxr+Ns/7Woaq9G/jj+1IdP8JG1gk7zxTRbTkfzXmOb\n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\n+y++LtIcOB5PrcLur8W9XuSTnkS9eG//1agFf7V95DRv/Qrsf3z+xayvLscKusrLnon+POMF7ts2q69+\nGCXUL7bP5b16nO15Ij7P5uHKp9nmC+zJk+yli+3Y+Tq6EaXkH8/2jcvx+pl2DqvfMMfeiK9ci8/rM1dj\nnV5j807zk5pvmv8vRZ+cjkG5EnNAbb7iDda4t3M19eETsd6f5NWuRJ+8lu0Px7NnzPYcf6LoUtw3tecC\nq9WnfYb3xdXOZ/Mnzc/jMUsv8y0WsvfxeiGbY6dizrzKm6a1prXwwvT+eZzf0lo7z2f/IK6j+a9N/vnp\nPf9afOa1bM5oYl/M9oGfRZ+8ETv5ad+j8JXz0bAf8InS9S/ECnqv7Qe89Xi8dTZG/EyMAluibmnX+wtT\ne0U7uLHWfJ5f9odN+4P/qbHQ3HuG1+e08V36QnvG+fOmfj7FP6/yM29EI5/zZ/TPXI0Bupg94xPx7wu8\nwmW+/k52Vl7w72Lf0Hn3ahp3qkVDF/tpKiS/TT3pR5Pq86Vb74Ri88cnoC798Sm+foWKyK1Ws5SUT926\nSDXvpAOeFJZfzzSW37QrvAldcOhphzI4Xp3SEH9Myti438cn/V7hAVNVmrrXev0NtMnVpi+46jh+P4fP\n+jXPfXySV1J73qLudVzzdXvvFBSp7TpX/fNQ6H6cn4K+9ROhUU4V6VeSNvlbt37Cp4DW+Jnsvk9Sn5tt\nc4VzKVJfomq3FL+hzX0Kz88+DWXst6hv/rj0xqVdTR3xS9Sf1uuPUsX8rPfb43zKM1KsvnUWz4/r8NUr\n1Et/mq9Dxfws+iB9lxrdrtd9ht94068v3XK1B9d+x5/xvM2Dp29d4hXfSnrdP8v+vUwFbe/zVuvcZkbb\nJ+ehh+7j/oara7fa8U/E62lMoe99DXMvxiKe8dZraI36wa7qiuPWX49TuTzUvWNcMPPe8vnzpv32JK+M\n+X/d/oJO+mW2IObGGSq+n/W2XcXrjCsi8ge3vS0nisj/3gxmJm1wx55SUmN9PPToZb99h3LTEVam+DDY\neIPN2R1MhkivZQIUDyJ7KqK1Wg9Xx5secZzPscE5Jr9Z+hwSs81tZ2JWwHlAB8Fztq2eUu1y1p1U5D20\nNMlAP4KSuvP2TyeERIdKtYd8IsJh9yO/s7oxhuyJyBae+d3L5F9kZhhkjzDs1hBlrT2hkWEgvrgWIHQy\n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`\n\n/** @type {Uint8Array} */\nlet dictionary\n\nexport function getDictionary() {\n  if (!dictionary) {\n    dictionary = new Uint8Array(122784)\n    const gzipString = atob(dictionaryGz64)\n    const gzipBytes = new Uint8Array(gzipString.length)\n    for (let i = 0; i < gzipString.length; i++) {\n      gzipBytes[i] = gzipString.charCodeAt(i)\n    }\n    gunzip(gzipBytes, dictionary)\n  }\n  return dictionary\n}\n","/* Copyright 2013 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n   Transformations on dictionary words.\n*/\n\nimport { getDictionary } from './brotliDictionary.js'\n\nconst kIdentity = 0\nconst kOmitLast1 = 1\nconst kOmitLast2 = 2\nconst kOmitLast3 = 3\nconst kOmitLast4 = 4\nconst kOmitLast5 = 5\nconst kOmitLast6 = 6\nconst kOmitLast7 = 7\nconst kOmitLast8 = 8\nconst kOmitLast9 = 9\nconst kUppercaseFirst = 10\nconst kUppercaseAll = 11\nconst kOmitFirst1 = 12\nconst kOmitFirst2 = 13\nconst kOmitFirst3 = 14\nconst kOmitFirst4 = 15\nconst kOmitFirst5 = 16\nconst kOmitFirst6 = 17\nconst kOmitFirst7 = 18\n// const kOmitFirst8 = 19\nconst kOmitFirst9 = 20\n\n/**\n * @param {string} prefix\n * @param {number} transform\n * @param {string} suffix\n */\nfunction Transform(prefix, transform, suffix) {\n  this.prefix = new Uint8Array(prefix.length)\n  this.transform = transform\n  this.suffix = new Uint8Array(suffix.length)\n\n  for (let i = 0; i < prefix.length; i++) this.prefix[i] = prefix.charCodeAt(i)\n  for (let i = 0; i < suffix.length; i++) this.suffix[i] = suffix.charCodeAt(i)\n}\n\nexport const kTransforms = [\n  new Transform( '', kIdentity, '' ),\n  new Transform( '', kIdentity, ' ' ),\n  new Transform( ' ', kIdentity, ' ' ),\n  new Transform( '', kOmitFirst1, '' ),\n  new Transform( '', kUppercaseFirst, ' ' ),\n  new Transform( '', kIdentity, ' the ' ),\n  new Transform( ' ', kIdentity, '' ),\n  new Transform( 's ', kIdentity, ' ' ),\n  new Transform( '', kIdentity, ' of ' ),\n  new Transform( '', kUppercaseFirst, '' ),\n  new Transform( '', kIdentity, ' and ' ),\n  new Transform( '', kOmitFirst2, '' ),\n  new Transform( '', kOmitLast1, '' ),\n  new Transform( ', ', kIdentity, ' ' ),\n  new Transform( '', kIdentity, ', ' ),\n  new Transform( ' ', kUppercaseFirst, ' ' ),\n  new Transform( '', kIdentity, ' in ' ),\n  new Transform( '', kIdentity, ' to ' ),\n  new Transform( 'e ', kIdentity, ' ' ),\n  new Transform( '', kIdentity, '\"' ),\n  new Transform( '', kIdentity, '.' ),\n  new Transform( '', kIdentity, '\">' ),\n  new Transform( '', kIdentity, '\\n' ),\n  new Transform( '', kOmitLast3, '' ),\n  new Transform( '', kIdentity, ']' ),\n  new Transform( '', kIdentity, ' for ' ),\n  new Transform( '', kOmitFirst3, '' ),\n  new Transform( '', kOmitLast2, '' ),\n  new Transform( '', kIdentity, ' a ' ),\n  new Transform( '', kIdentity, ' that ' ),\n  new Transform( ' ', kUppercaseFirst, '' ),\n  new Transform( '', kIdentity, '. ' ),\n  new Transform( '.', kIdentity, '' ),\n  new Transform( ' ', kIdentity, ', ' ),\n  new Transform( '', kOmitFirst4, '' ),\n  new Transform( '', kIdentity, ' with ' ),\n  new Transform( '', kIdentity, '\\'' ),\n  new Transform( '', kIdentity, ' from ' ),\n  new Transform( '', kIdentity, ' by ' ),\n  new Transform( '', kOmitFirst5, '' ),\n  new Transform( '', kOmitFirst6, '' ),\n  new Transform( ' the ', kIdentity, '' ),\n  new Transform( '', kOmitLast4, '' ),\n  new Transform( '', kIdentity, '. The ' ),\n  new Transform( '', kUppercaseAll, '' ),\n  new Transform( '', kIdentity, ' on ' ),\n  new Transform( '', kIdentity, ' as ' ),\n  new Transform( '', kIdentity, ' is ' ),\n  new Transform( '', kOmitLast7, '' ),\n  new Transform( '', kOmitLast1, 'ing ' ),\n  new Transform( '', kIdentity, '\\n\\t' ),\n  new Transform( '', kIdentity, ':' ),\n  new Transform( ' ', kIdentity, '. ' ),\n  new Transform( '', kIdentity, 'ed ' ),\n  new Transform( '', kOmitFirst9, '' ),\n  new Transform( '', kOmitFirst7, '' ),\n  new Transform( '', kOmitLast6, '' ),\n  new Transform( '', kIdentity, '(' ),\n  new Transform( '', kUppercaseFirst, ', ' ),\n  new Transform( '', kOmitLast8, '' ),\n  new Transform( '', kIdentity, ' at ' ),\n  new Transform( '', kIdentity, 'ly ' ),\n  new Transform( ' the ', kIdentity, ' of ' ),\n  new Transform( '', kOmitLast5, '' ),\n  new Transform( '', kOmitLast9, '' ),\n  new Transform( ' ', kUppercaseFirst, ', ' ),\n  new Transform( '', kUppercaseFirst, '\"' ),\n  new Transform( '.', kIdentity, '(' ),\n  new Transform( '', kUppercaseAll, ' ' ),\n  new Transform( '', kUppercaseFirst, '\">' ),\n  new Transform( '', kIdentity, '=\"' ),\n  new Transform( ' ', kIdentity, '.' ),\n  new Transform( '.com/', kIdentity, '' ),\n  new Transform( ' the ', kIdentity, ' of the ' ),\n  new Transform( '', kUppercaseFirst, '\\'' ),\n  new Transform( '', kIdentity, '. This ' ),\n  new Transform( '', kIdentity, ',' ),\n  new Transform( '.', kIdentity, ' ' ),\n  new Transform( '', kUppercaseFirst, '(' ),\n  new Transform( '', kUppercaseFirst, '.' ),\n  new Transform( '', kIdentity, ' not ' ),\n  new Transform( ' ', kIdentity, '=\"' ),\n  new Transform( '', kIdentity, 'er ' ),\n  new Transform( ' ', kUppercaseAll, ' ' ),\n  new Transform( '', kIdentity, 'al ' ),\n  new Transform( ' ', kUppercaseAll, '' ),\n  new Transform( '', kIdentity, '=\\'' ),\n  new Transform( '', kUppercaseAll, '\"' ),\n  new Transform( '', kUppercaseFirst, '. ' ),\n  new Transform( ' ', kIdentity, '(' ),\n  new Transform( '', kIdentity, 'ful ' ),\n  new Transform( ' ', kUppercaseFirst, '. ' ),\n  new Transform( '', kIdentity, 'ive ' ),\n  new Transform( '', kIdentity, 'less ' ),\n  new Transform( '', kUppercaseAll, '\\'' ),\n  new Transform( '', kIdentity, 'est ' ),\n  new Transform( ' ', kUppercaseFirst, '.' ),\n  new Transform( '', kUppercaseAll, '\">' ),\n  new Transform( ' ', kIdentity, '=\\'' ),\n  new Transform( '', kUppercaseFirst, ',' ),\n  new Transform( '', kIdentity, 'ize ' ),\n  new Transform( '', kUppercaseAll, '.' ),\n  new Transform( '\\xc2\\xa0', kIdentity, '' ),\n  new Transform( ' ', kIdentity, ',' ),\n  new Transform( '', kUppercaseFirst, '=\"' ),\n  new Transform( '', kUppercaseAll, '=\"' ),\n  new Transform( '', kIdentity, 'ous ' ),\n  new Transform( '', kUppercaseAll, ', ' ),\n  new Transform( '', kUppercaseFirst, '=\\'' ),\n  new Transform( ' ', kUppercaseFirst, ',' ),\n  new Transform( ' ', kUppercaseAll, '=\"' ),\n  new Transform( ' ', kUppercaseAll, ', ' ),\n  new Transform( '', kUppercaseAll, ',' ),\n  new Transform( '', kUppercaseAll, '(' ),\n  new Transform( '', kUppercaseAll, '. ' ),\n  new Transform( ' ', kUppercaseAll, '.' ),\n  new Transform( '', kUppercaseAll, '=\\'' ),\n  new Transform( ' ', kUppercaseAll, '. ' ),\n  new Transform( ' ', kUppercaseFirst, '=\"' ),\n  new Transform( ' ', kUppercaseAll, '=\\'' ),\n  new Transform( ' ', kUppercaseFirst, '=\\'' ),\n]\n\nexport const kNumTransforms = kTransforms.length\n\n/**\n * @param {Uint8Array} p\n * @param {number} i\n * @returns {number}\n */\nfunction ToUpperCase(p, i) {\n  if (p[i] < 0xc0) {\n    if (p[i] >= 97 && p[i] <= 122) {\n      p[i] ^= 32\n    }\n    return 1\n  }\n\n  /* An overly simplified uppercasing model for utf-8. */\n  if (p[i] < 0xe0) {\n    p[i + 1] ^= 32\n    return 2\n  }\n\n  /* An arbitrary transform for three byte characters. */\n  p[i + 2] ^= 5\n  return 3\n}\n\n/**\n * @param {Uint8Array} dst\n * @param {number} idx\n * @param {number} word\n * @param {number} len\n * @param {number} transform\n * @returns {number}\n */\nexport function transformDictionaryWord(dst, idx, word, len, transform) {\n  const dictionary = getDictionary()\n  const { prefix } = kTransforms[transform]\n  const { suffix } = kTransforms[transform]\n  const t = kTransforms[transform].transform\n  let skip = t < kOmitFirst1 ? 0 : t - (kOmitFirst1 - 1)\n  const start_idx = idx\n\n  if (skip > len) skip = len\n\n  let prefix_pos = 0\n  while (prefix_pos < prefix.length) {\n    dst[idx++] = prefix[prefix_pos++]\n  }\n\n  word += skip\n  len -= skip\n\n  if (t <= kOmitLast9) len -= t\n\n  for (let i = 0; i < len; i++) {\n    dst[idx++] = dictionary[word + i]\n  }\n\n  let uppercase = idx - len\n\n  if (t === kUppercaseFirst) {\n    ToUpperCase(dst, uppercase)\n  } else if (t === kUppercaseAll) {\n    while (len > 0) {\n      const step = ToUpperCase(dst, uppercase)\n      uppercase += step\n      len -= step\n    }\n  }\n\n  let suffix_pos = 0\n  while (suffix_pos < suffix.length) {\n    dst[idx++] = suffix[suffix_pos++]\n  }\n\n  return idx - start_idx\n}\n","/* Adapted from https://github.com/foliojs/brotli.js\n * Copyright 2015 Devon Govett, MIT License\n * Copyright 2013 Google Inc, Apache License 2.0\n */\n\nimport BrotliBitReader from './brotliBitReader.js'\nimport { lookup, lookupOffsets } from './brotliContext.js'\nimport { HuffmanCode, readHuffmanCode, readSymbol } from './brotliHuffman.js'\nimport { kBlockLengthPrefixCode, kCopyLengthPrefixCode, kCopyRangeLut, kInsertLengthPrefixCode, kInsertRangeLut } from './brotliPrefix.js'\nimport { BrotliInput, BrotliOutput } from './brotliStreams.js'\nimport { kNumTransforms, transformDictionaryWord } from './brotliTransform.js'\n\nconst kNumLiteralCodes = 256\nconst kNumInsertAndCopyCodes = 704\nconst kNumBlockLengthCodes = 26\nconst kLiteralContextBits = 6\nconst kDistanceContextBits = 2\n\n/* Maximum possible Huffman table size for an alphabet size of 704, max code\n * length 15 and root table bits 8. */\nconst HUFFMAN_MAX_TABLE_SIZE = 1080\n\nconst NUM_DISTANCE_SHORT_CODES = 16\nconst kDistanceShortCodeIndexOffset = new Uint8Array([\n  3, 2, 1, 0, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2,\n])\n\nconst kDistanceShortCodeValueOffset = new Int8Array([\n  0, 0, 0, 0, -1, 1, -2, 2, -3, 3, -1, 1, -2, 2, -3, 3,\n])\n\nconst kMaxHuffmanTableSize = new Uint16Array([\n  256, 402, 436, 468, 500, 534, 566, 598, 630, 662, 694, 726, 758, 790, 822,\n  854, 886, 920, 952, 984, 1016, 1048, 1080,\n])\n\n// Brotli dictionary\nconst offsetsByLength = new Uint32Array([\n  0, 0, 0, 0, 0, 4096, 9216, 21504, 35840, 44032,\n  53248, 63488, 74752, 87040, 93696, 100864, 104704, 106752, 108928, 113536,\n  115968, 118528, 119872, 121280, 122016,\n])\n\nconst sizeBitsByLength = new Uint8Array([\n  0, 0, 0, 0, 10, 10, 11, 11, 10, 10,\n  10, 10, 10, 9, 9, 8, 7, 7, 8, 7,\n  7, 6, 6, 5, 5,\n])\n\nconst minDictionaryWordLength = 4\nconst maxDictionaryWordLength = 24\n\n/**\n * @param {Uint8Array} input\n * @param {number} outputLength\n * @returns {Uint8Array}\n */\nexport function BROTLI(input, outputLength) {\n  const output = new Uint8Array(outputLength)\n  const brotliInput = new BrotliInput(input)\n  const brotliOutput = new BrotliOutput(output)\n  brotli(brotliInput, brotliOutput)\n  return output\n}\n\n/**\n * @param {BrotliInput} input\n * @param {BrotliOutput} output\n */\nfunction brotli(input, output) {\n  let pos = 0\n  let input_end = 0\n  let window_bits = 0\n  let max_distance = 0\n  /* This ring buffer holds a few past copy distances that will be used by */\n  /* some special distance codes. */\n  const dist_rb = [ 16, 15, 11, 4 ]\n  let dist_rb_idx = 0\n  /* The previous 2 bytes used for context */\n  let prev_byte1 = 0\n  let prev_byte2 = 0\n  const hgroup = [new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0), new HuffmanTreeGroup(0, 0)]\n\n  /* We need the slack region for the following reasons:\n       - always doing two 8-byte copies for fast backward copying\n       - transforms\n       - flushing the input ringbuffer when decoding uncompressed blocks */\n  const kRingBufferWriteAheadSlack = 128 + BrotliBitReader.READ_SIZE\n\n  const br = new BrotliBitReader(input)\n\n  /* Decode window size. */\n  window_bits = decodeWindowBits(br)\n  const max_backward_distance = (1 << window_bits) - 16\n\n  const ringbuffer_size = 1 << window_bits\n  const ringbuffer_mask = ringbuffer_size - 1\n  const ringbuffer = new Uint8Array(ringbuffer_size + kRingBufferWriteAheadSlack + maxDictionaryWordLength)\n  const ringbuffer_end = ringbuffer_size\n\n  const block_type_trees = []\n  const block_len_trees = []\n  for (let x = 0; x < 3 * HUFFMAN_MAX_TABLE_SIZE; x++) {\n    block_type_trees[x] = new HuffmanCode(0, 0)\n    block_len_trees[x] = new HuffmanCode(0, 0)\n  }\n\n  while (!input_end) {\n    let meta_block_remaining_len = 0\n    const block_length = [ 1 << 28, 1 << 28, 1 << 28 ]\n    const block_type = [ 0 ]\n    const num_block_types = [ 1, 1, 1 ]\n    const block_type_rb = [ 0, 1, 0, 1, 0, 1 ]\n    const block_type_rb_index = [ 0 ]\n    let context_offset = 0\n\n    for (let i = 0; i < 3; i++) {\n      hgroup[i].codes = []\n      hgroup[i].htrees = new Uint32Array()\n    }\n\n    br.readMoreInput()\n\n    const _out = DecodeMetaBlockLength(br)\n    meta_block_remaining_len = _out.meta_block_length\n    if (pos + meta_block_remaining_len > output.buffer.length) {\n      /* We need to grow the output buffer to fit the additional data. */\n      const tmp = new Uint8Array( pos + meta_block_remaining_len )\n      tmp.set( output.buffer )\n      output.buffer = tmp\n    }\n    input_end = _out.input_end\n\n    if (_out.is_metadata) {\n      jumpToByteBoundary(br)\n\n      for (; meta_block_remaining_len > 0; --meta_block_remaining_len) {\n        br.readMoreInput()\n        /* Read one byte and ignore it. */\n        br.readBits(8)\n      }\n\n      continue\n    }\n\n    if (meta_block_remaining_len === 0) continue\n\n    if (_out.is_uncompressed) {\n      br.bit_pos_ = br.bit_pos_ + 7 & ~7\n      copyUncompressedBlockToOutput(output, meta_block_remaining_len, pos, ringbuffer, ringbuffer_mask, br)\n      pos += meta_block_remaining_len\n      continue\n    }\n\n    for (let i = 0; i < 3; i++) {\n      num_block_types[i] = decodeVarLenUint8(br) + 1\n      if (num_block_types[i] >= 2) {\n        readHuffmanCode(num_block_types[i] + 2, block_type_trees, i * HUFFMAN_MAX_TABLE_SIZE, br)\n        readHuffmanCode(kNumBlockLengthCodes, block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br)\n        block_length[i] = readBlockLength(block_len_trees, i * HUFFMAN_MAX_TABLE_SIZE, br)\n        block_type_rb_index[i] = 1\n      }\n    }\n\n    br.readMoreInput()\n\n    const distance_postfix_bits = br.readBits(2)\n    const num_direct_distance_codes = NUM_DISTANCE_SHORT_CODES + (br.readBits(4) << distance_postfix_bits)\n    const distance_postfix_mask = (1 << distance_postfix_bits) - 1\n    const num_distance_codes = num_direct_distance_codes + (48 << distance_postfix_bits)\n    const context_modes = new Uint8Array(num_block_types[0])\n\n    for (let i = 0; i < num_block_types[0]; i++) {\n      br.readMoreInput()\n      context_modes[i] = br.readBits(2) << 1\n    }\n\n    const _o1 = DecodeContextMap(num_block_types[0] << kLiteralContextBits, br)\n    const num_literal_htrees = _o1.num_htrees\n    const { context_map } = _o1\n\n    const _o2 = DecodeContextMap(num_block_types[2] << kDistanceContextBits, br)\n    const num_dist_htrees = _o2.num_htrees\n    const dist_context_map = _o2.context_map\n\n    hgroup[0] = new HuffmanTreeGroup(kNumLiteralCodes, num_literal_htrees)\n    hgroup[1] = new HuffmanTreeGroup(kNumInsertAndCopyCodes, num_block_types[1])\n    hgroup[2] = new HuffmanTreeGroup(num_distance_codes, num_dist_htrees)\n\n    for (let i = 0; i < 3; ++i) {\n      hgroup[i].decode(br)\n    }\n\n    let context_map_slice = 0\n    let dist_context_map_slice = 0\n    let context_mode = context_modes[block_type[0]]\n    let context_lookup_offset1 = lookupOffsets[context_mode]\n    let context_lookup_offset2 = lookupOffsets[context_mode + 1]\n    let htree_command = hgroup[1].htrees[0]\n\n    while (meta_block_remaining_len > 0) {\n      let distance_code\n\n      br.readMoreInput()\n\n      if (block_length[1] === 0) {\n        decodeBlockType(num_block_types[1],\n          block_type_trees, 1, block_type, block_type_rb,\n          block_type_rb_index, br)\n        block_length[1] = readBlockLength(block_len_trees, HUFFMAN_MAX_TABLE_SIZE, br)\n        htree_command = hgroup[1].htrees[block_type[1]]\n      }\n      block_length[1]--\n      const cmd_code = readSymbol(hgroup[1].codes, htree_command, br)\n      let range_idx = cmd_code >> 6\n      if (range_idx >= 2) {\n        range_idx -= 2\n        distance_code = -1\n      } else {\n        distance_code = 0\n      }\n      const insert_code = kInsertRangeLut[range_idx] + (cmd_code >> 3 & 7)\n      const copy_code = kCopyRangeLut[range_idx] + (cmd_code & 7)\n      const insert_length = kInsertLengthPrefixCode[insert_code].offset +\n          br.readBits(kInsertLengthPrefixCode[insert_code].nbits)\n      const copy_length = kCopyLengthPrefixCode[copy_code].offset +\n          br.readBits(kCopyLengthPrefixCode[copy_code].nbits)\n      prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask]\n      prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask]\n      for (let j = 0; j < insert_length; j++) {\n        br.readMoreInput()\n\n        if (block_length[0] === 0) {\n          decodeBlockType(num_block_types[0],\n            block_type_trees, 0, block_type, block_type_rb,\n            block_type_rb_index, br)\n          block_length[0] = readBlockLength(block_len_trees, 0, br)\n          context_offset = block_type[0] << kLiteralContextBits\n          context_map_slice = context_offset\n          context_mode = context_modes[block_type[0]]\n          context_lookup_offset1 = lookupOffsets[context_mode]\n          context_lookup_offset2 = lookupOffsets[context_mode + 1]\n        }\n        const context = lookup[context_lookup_offset1 + prev_byte1] |\n                   lookup[context_lookup_offset2 + prev_byte2]\n        const literal_htree_index = context_map[context_map_slice + context]\n        block_length[0]--\n        prev_byte2 = prev_byte1\n        prev_byte1 = readSymbol(hgroup[0].codes, hgroup[0].htrees[literal_htree_index], br)\n        ringbuffer[pos & ringbuffer_mask] = prev_byte1\n        if ((pos & ringbuffer_mask) === ringbuffer_mask) {\n          output.write(ringbuffer, ringbuffer_size)\n        }\n        pos++\n      }\n      meta_block_remaining_len -= insert_length\n      if (meta_block_remaining_len <= 0) break\n\n      if (distance_code < 0) {\n        br.readMoreInput()\n        if (block_length[2] === 0) {\n          decodeBlockType(num_block_types[2],\n            block_type_trees, 2, block_type, block_type_rb,\n            block_type_rb_index, br)\n          block_length[2] = readBlockLength(block_len_trees, 2 * HUFFMAN_MAX_TABLE_SIZE, br)\n          dist_context_map_slice = block_type[2] << kDistanceContextBits\n        }\n        block_length[2]--\n        const context = (copy_length > 4 ? 3 : copy_length - 2) & 0xff\n        const dist_htree_index = dist_context_map[dist_context_map_slice + context]\n        distance_code = readSymbol(hgroup[2].codes, hgroup[2].htrees[dist_htree_index], br)\n        if (distance_code >= num_direct_distance_codes) {\n          distance_code -= num_direct_distance_codes\n          const postfix = distance_code & distance_postfix_mask\n          distance_code >>= distance_postfix_bits\n          const nbits = (distance_code >> 1) + 1\n          const offset = (2 + (distance_code & 1) << nbits) - 4\n          distance_code = num_direct_distance_codes +\n              (offset + br.readBits(nbits) <<\n               distance_postfix_bits) + postfix\n        }\n      }\n\n      /* Convert the distance code to the actual distance by possibly looking */\n      /* up past distnaces from the ringbuffer. */\n      const distance = translateShortCodes(distance_code, dist_rb, dist_rb_idx)\n      if (distance < 0) throw new Error('[BrotliDecompress] invalid distance')\n\n      if (pos < max_backward_distance && max_distance !== max_backward_distance) {\n        max_distance = pos\n      } else {\n        max_distance = max_backward_distance\n      }\n\n      let copy_dst = pos & ringbuffer_mask\n\n      if (distance > max_distance) {\n        if (copy_length >= minDictionaryWordLength && copy_length <= maxDictionaryWordLength) {\n          let offset = offsetsByLength[copy_length]\n          const word_id = distance - max_distance - 1\n          const shift = sizeBitsByLength[copy_length]\n          const mask = (1 << shift) - 1\n          const word_idx = word_id & mask\n          const transform_idx = word_id >> shift\n          offset += word_idx * copy_length\n          if (transform_idx < kNumTransforms) {\n            const len = transformDictionaryWord(ringbuffer, copy_dst, offset, copy_length, transform_idx)\n            copy_dst += len\n            pos += len\n            meta_block_remaining_len -= len\n            if (copy_dst >= ringbuffer_end) {\n              output.write(ringbuffer, ringbuffer_size)\n\n              for (let _x = 0; _x < copy_dst - ringbuffer_end; _x++)\n                ringbuffer[_x] = ringbuffer[ringbuffer_end + _x]\n            }\n          } else {\n            throw new Error('Invalid backward reference')\n          }\n        } else {\n          throw new Error('Invalid backward reference')\n        }\n      } else {\n        if (distance_code > 0) {\n          dist_rb[dist_rb_idx & 3] = distance\n          dist_rb_idx++\n        }\n\n        if (copy_length > meta_block_remaining_len) {\n          throw new Error('Invalid backward reference')\n        }\n\n        for (let j = 0; j < copy_length; j++) {\n          ringbuffer[pos & ringbuffer_mask] = ringbuffer[pos - distance & ringbuffer_mask]\n          if ((pos & ringbuffer_mask) === ringbuffer_mask) {\n            output.write(ringbuffer, ringbuffer_size)\n          }\n          pos++\n          meta_block_remaining_len--\n        }\n      }\n\n      /* When we get here, we must have inserted at least one literal and */\n      /* made a copy of at least length two, therefore accessing the last 2 */\n      /* bytes is valid. */\n      prev_byte1 = ringbuffer[pos - 1 & ringbuffer_mask]\n      prev_byte2 = ringbuffer[pos - 2 & ringbuffer_mask]\n    }\n\n    /* Protect pos from overflow, wrap it around at every GB of input data */\n    pos &= 0x3fffffff\n  }\n\n  output.write(ringbuffer, pos & ringbuffer_mask)\n}\n\n/**\n * @param {BrotliBitReader} br\n * @returns {number}\n */\nfunction decodeWindowBits(br) {\n  if (br.readBits(1) === 0) return 16\n\n  let n = br.readBits(3)\n  if (n > 0) return 17 + n\n\n  n = br.readBits(3)\n  if (n > 0) return 8 + n\n\n  return 17\n}\n\n/**\n * @param {number} max_block_type\n * @param {HuffmanCode[]} trees\n * @param {number} tree_type\n * @param {number[]} block_types\n * @param {number[]} ringbuffers\n * @param {number[]} indexes\n * @param {BrotliBitReader} br\n */\nfunction decodeBlockType(max_block_type, trees, tree_type, block_types, ringbuffers, indexes, br) {\n  const ringbuffer = tree_type * 2\n  const index = tree_type\n  const type_code = readSymbol(trees, tree_type * HUFFMAN_MAX_TABLE_SIZE, br)\n  let block_type\n  if (type_code === 0) {\n    block_type = ringbuffers[ringbuffer + (indexes[index] & 1)]\n  } else if (type_code === 1) {\n    block_type = ringbuffers[ringbuffer + (indexes[index] - 1 & 1)] + 1\n  } else {\n    block_type = type_code - 2\n  }\n  if (block_type >= max_block_type) {\n    block_type -= max_block_type\n  }\n  block_types[tree_type] = block_type\n  ringbuffers[ringbuffer + (indexes[index] & 1)] = block_type\n  ++indexes[index]\n}\n\n/**\n * Contains a collection of huffman trees with the same alphabet size.\n *\n * @param {number} alphabet_size\n * @param {number} num_htrees\n */\nfunction HuffmanTreeGroup(alphabet_size, num_htrees) {\n  this.alphabet_size = alphabet_size\n  this.num_htrees = num_htrees\n  this.codes = new Array(num_htrees + num_htrees * kMaxHuffmanTableSize[alphabet_size + 31 >>> 5])\n  this.htrees = new Uint32Array(num_htrees)\n}\n\n/**\n * @param {BrotliBitReader} br\n */\nHuffmanTreeGroup.prototype.decode = function(br) {\n  let next = 0\n  for (let i = 0; i < this.num_htrees; i++) {\n    this.htrees[i] = next\n    next += readHuffmanCode(this.alphabet_size, this.codes, next, br)\n  }\n}\n\n/**\n * @param {HuffmanCode[]} table\n * @param {number} index\n * @param {BrotliBitReader} br\n * @returns {number}\n */\nfunction readBlockLength(table, index, br) {\n  const code = readSymbol(table, index, br)\n  const { nbits } = kBlockLengthPrefixCode[code]\n  return kBlockLengthPrefixCode[code].offset + br.readBits(nbits)\n}\n\n/**\n * @param {number} code\n * @param {number[]} ringbuffer\n * @param {number} index\n * @returns {number}\n */\nfunction translateShortCodes(code, ringbuffer, index) {\n  if (code < NUM_DISTANCE_SHORT_CODES) {\n    index += kDistanceShortCodeIndexOffset[code]\n    index &= 3\n    return ringbuffer[index] + kDistanceShortCodeValueOffset[code]\n  } else {\n    return code - NUM_DISTANCE_SHORT_CODES + 1\n  }\n}\n\n/**\n * @param {*} output\n * @param {number} len\n * @param {number} pos\n * @param {Uint8Array} ringbuffer\n * @param {number} ringbuffer_mask\n * @param {BrotliBitReader} br\n */\nfunction copyUncompressedBlockToOutput(output, len, pos, ringbuffer, ringbuffer_mask, br) {\n  const rb_size = ringbuffer_mask + 1\n  let rb_pos = pos & ringbuffer_mask\n  let br_pos = br.pos_ & BrotliBitReader.IBUF_MASK\n\n  /* For short lengths copy byte-by-byte */\n  if (len < 8 || br.bit_pos_ + (len << 3) < br.bit_end_pos_) {\n    while (len-- > 0) {\n      br.readMoreInput()\n      ringbuffer[rb_pos++] = br.readBits(8)\n      if (rb_pos === rb_size) {\n        output.write(ringbuffer, rb_size)\n        rb_pos = 0\n      }\n    }\n    return\n  }\n\n  if (br.bit_end_pos_ < 32) {\n    throw new Error('[CopyUncompressedBlockToOutput] br.bit_end_pos_ < 32')\n  }\n\n  /* Copy remaining 0-4 bytes from br.val_ to ringbuffer. */\n  while (br.bit_pos_ < 32) {\n    ringbuffer[rb_pos] = br.val_ >>> br.bit_pos_\n    br.bit_pos_ += 8\n    rb_pos++\n    len--\n  }\n\n  /* Copy remaining bytes from br.buf_ to ringbuffer. */\n  let nbytes = br.bit_end_pos_ - br.bit_pos_ >> 3\n  if (br_pos + nbytes > BrotliBitReader.IBUF_MASK) {\n    const tail = BrotliBitReader.IBUF_MASK + 1 - br_pos\n    for (let x = 0; x < tail; x++)\n      ringbuffer[rb_pos + x] = br.buf_[br_pos + x]\n\n    nbytes -= tail\n    rb_pos += tail\n    len -= tail\n    br_pos = 0\n  }\n\n  for (let x = 0; x < nbytes; x++)\n    ringbuffer[rb_pos + x] = br.buf_[br_pos + x]\n\n  rb_pos += nbytes\n  len -= nbytes\n\n  /* If we wrote past the logical end of the ringbuffer, copy the tail of the\n     ringbuffer to its beginning and flush the ringbuffer to the output. */\n  if (rb_pos >= rb_size) {\n    output.write(ringbuffer, rb_size)\n    rb_pos -= rb_size\n    for (let x = 0; x < rb_pos; x++)\n      ringbuffer[x] = ringbuffer[rb_size + x]\n  }\n\n  /* If we have more to copy than the remaining size of the ringbuffer, then we\n     first fill the ringbuffer from the input and then flush the ringbuffer to\n     the output */\n  while (rb_pos + len >= rb_size) {\n    nbytes = rb_size - rb_pos\n    if (br.input_.read(ringbuffer, rb_pos, nbytes) < nbytes) {\n      throw new Error('[CopyUncompressedBlockToOutput] not enough bytes')\n    }\n    output.write(ringbuffer, rb_size)\n    len -= nbytes\n    rb_pos = 0\n  }\n\n  /* Copy straight from the input onto the ringbuffer. The ringbuffer will be\n     flushed to the output at a later time. */\n  if (br.input_.read(ringbuffer, rb_pos, len) < len) {\n    throw new Error('[CopyUncompressedBlockToOutput] not enough bytes')\n  }\n\n  /* Restore the state of the bit reader. */\n  br.reset()\n}\n\n/**\n * Decodes a number in the range [0..255], by reading 1 - 11 bits.\n * @param {BrotliBitReader} br\n * @returns {number}\n */\nfunction decodeVarLenUint8(br) {\n  if (br.readBits(1)) {\n    const nbits = br.readBits(3)\n    if (nbits === 0) {\n      return 1\n    } else {\n      return br.readBits(nbits) + (1 << nbits)\n    }\n  }\n  return 0\n}\n\nfunction MetaBlockLength() {\n  this.meta_block_length = 0\n  this.input_end = 0\n  this.is_uncompressed = 0\n  this.is_metadata = false\n}\n\n/**\n * @param {BrotliBitReader} br\n * @returns {MetaBlockLength}\n */\nfunction DecodeMetaBlockLength(br) {\n  const out = new MetaBlockLength\n\n  out.input_end = br.readBits(1)\n  if (out.input_end && br.readBits(1)) {\n    return out\n  }\n\n  const size_nibbles = br.readBits(2) + 4\n  if (size_nibbles === 7) {\n    out.is_metadata = true\n\n    if (br.readBits(1) !== 0)\n      throw new Error('Invalid reserved bit')\n\n    const size_bytes = br.readBits(2)\n    if (size_bytes === 0)\n      return out\n\n    for (let i = 0; i < size_bytes; i++) {\n      const next_byte = br.readBits(8)\n      if (i + 1 === size_bytes && size_bytes > 1 && next_byte === 0)\n        throw new Error('Invalid size byte')\n\n      out.meta_block_length |= next_byte << i * 8\n    }\n  } else {\n    for (let i = 0; i < size_nibbles; i++) {\n      const next_nibble = br.readBits(4)\n      if (i + 1 === size_nibbles && size_nibbles > 4 && next_nibble === 0)\n        throw new Error('Invalid size nibble')\n\n      out.meta_block_length |= next_nibble << i * 4\n    }\n  }\n\n  out.meta_block_length++\n\n  if (!out.input_end && !out.is_metadata) {\n    out.is_uncompressed = br.readBits(1)\n  }\n\n  return out\n}\n\n/**\n * @param {number} context_map_size\n * @param {BrotliBitReader} br\n * @returns {{ num_htrees: number, context_map: Uint8Array }}\n */\nfunction DecodeContextMap(context_map_size, br) {\n  let max_run_length_prefix = 0\n\n  br.readMoreInput()\n  const num_htrees = decodeVarLenUint8(br) + 1\n\n  const context_map = new Uint8Array(context_map_size)\n  if (num_htrees <= 1) {\n    return { num_htrees, context_map }\n  }\n\n  const use_rle_for_zeros = br.readBits(1)\n  if (use_rle_for_zeros) {\n    max_run_length_prefix = br.readBits(4) + 1\n  }\n\n  const table = []\n  for (let i = 0; i < HUFFMAN_MAX_TABLE_SIZE; i++) {\n    table[i] = new HuffmanCode(0, 0)\n  }\n\n  readHuffmanCode(num_htrees + max_run_length_prefix, table, 0, br)\n\n  for (let i = 0; i < context_map_size;) {\n    br.readMoreInput()\n    const code = readSymbol(table, 0, br)\n    if (code === 0) {\n      context_map[i] = 0\n      i++\n    } else if (code <= max_run_length_prefix) {\n      let reps = 1 + (1 << code) + br.readBits(code)\n      while (--reps) {\n        if (i >= context_map_size) {\n          throw new Error('[DecodeContextMap] i >= context_map_size')\n        }\n        context_map[i] = 0\n        i++\n      }\n    } else {\n      context_map[i] = code - max_run_length_prefix\n      i++\n    }\n  }\n  if (br.readBits(1)) {\n    inverseMoveToFrontTransform(context_map, context_map_size)\n  }\n\n  return { num_htrees, context_map }\n}\n\n/**\n * @param {Uint8Array} v\n * @param {number} index\n */\nfunction moveToFront(v, index) {\n  const value = v[index]\n  for (let i = index; i; i--) v[i] = v[i - 1]\n  v[0] = value\n}\n\n/**\n * @param {Uint8Array} v\n * @param {number} v_len\n */\nfunction inverseMoveToFrontTransform(v, v_len) {\n  const mtf = new Uint8Array(256)\n  for (let i = 0; i < 256; i++) {\n    mtf[i] = i\n  }\n  for (let i = 0; i < v_len; i++) {\n    const index = v[i]\n    v[i] = mtf[index]\n    if (index) moveToFront(mtf, index)\n  }\n}\n\n/**\n * Advances the bit reader position to the next byte boundary and verifies\n * that any skipped bits are set to zero.\n * @param {BrotliBitReader} br\n * @returns {boolean}\n */\nfunction jumpToByteBoundary(br) {\n  const new_bit_pos = br.bit_pos_ + 7 & ~7\n  return !br.readBits(new_bit_pos - br.bit_pos_)\n}\n","/**\n * LZ4 decompression with legacy hadoop support.\n * https://github.com/apache/arrow/blob/apache-arrow-16.1.0/cpp/src/arrow/util/compression_lz4.cc#L475\n *\n * @param {Uint8Array} input\n * @param {number} outputLength\n * @returns {Uint8Array}\n */\nexport function LZ4(input, outputLength) {\n  const output = new Uint8Array(outputLength)\n  try {\n    let i = 0 // input index\n    let o = 0 // output index\n    while (i < input.length - 8) {\n      const expectedOutputLength = input[i++] << 24 | input[i++] << 16 | input[i++] << 8 | input[i++]\n      const expectedInputLength = input[i++] << 24 | input[i++] << 16 | input[i++] << 8 | input[i++]\n      if (input.length - i < expectedInputLength) throw new Error('lz4 not hadoop')\n      if (output.length < expectedOutputLength) throw new Error('lz4 not hadoop')\n\n      // decompress and compare with expected\n      const chunk = lz4basic(input.subarray(i, i + expectedInputLength), output, o)\n      if (chunk !== expectedOutputLength) throw new Error('lz4 not hadoop')\n      i += expectedInputLength\n      o += expectedOutputLength\n\n      if (i === input.length) return output\n    }\n    if (i < input.length) throw new Error('lz4 not hadoop')\n  } catch (error) {\n    if (error instanceof Error && error.message !== 'lz4 not hadoop') throw error\n    // fallback to basic lz4\n    lz4basic(input, output, 0)\n  }\n  return output\n}\n\n/**\n * Basic LZ4 block decompression.\n *\n * @param {Uint8Array} input\n * @param {number} outputLength\n * @returns {Uint8Array}\n */\nexport function LZ4_RAW(input, outputLength) {\n  const output = new Uint8Array(outputLength)\n  lz4basic(input, output, 0)\n  return output\n}\n\n/**\n * @param {Uint8Array} input\n * @param {Uint8Array} output\n * @param {number} outputIndex\n * @returns {number} bytes written\n */\nfunction lz4basic(input, output, outputIndex) {\n  let len = outputIndex // output position\n  for (let i = 0; i < input.length;) {\n    const token = input[i++]\n\n    let literals = token >> 4\n    if (literals) {\n      // literal length\n      let byte = literals + 240\n      while (byte === 255) literals += byte = input[i++]\n      // copy literals\n      output.set(input.subarray(i, i + literals), len)\n      len += literals\n      i += literals\n      if (i >= input.length) return len - outputIndex\n    }\n\n    const offset = input[i++] | input[i++] << 8\n    if (!offset || offset > len) {\n      throw new Error(`lz4 offset out of range ${offset}`)\n    }\n    // match length\n    let matchLength = (token & 0xf) + 4 // minmatch 4\n    let byte = matchLength + 240\n    while (byte === 255) matchLength += byte = input[i++]\n    // copy match\n    // TODO: fast path when no overlap\n    let pos = len - offset\n    const end = len + matchLength\n    while (len < end) output[len++] = output[pos++]\n  }\n  return len - outputIndex\n}\n","import { decompress as ZSTD } from 'fzstd'\nimport { snappyUncompressor } from 'hysnappy'\nimport { BROTLI } from './brotli.js'\nimport { gunzip } from './gzip.js'\nimport { LZ4, LZ4_RAW } from './lz4.js'\n\n/**\n * @type {import('hyparquet').Compressors}\n */\nexport const compressors = {\n  SNAPPY: snappyUncompressor(),\n  GZIP: (input, length) => {\n    const out = new Uint8Array(length)\n    gunzip(input, out)\n    return out\n  },\n  BROTLI,\n  ZSTD: input => ZSTD(input),\n  LZ4,\n  LZ4_RAW,\n}\n","import { asyncBufferFromUrl, parquetQuery } from 'hyparquet'\nimport { compressors } from 'hyparquet-compressors'\n\nself.onmessage = async ({ data }) => {\n  const { metadata, asyncBuffer, rowStart, rowEnd, orderBy } = data\n  const file = await asyncBufferFromUrl(asyncBuffer.url, asyncBuffer.byteLength)\n  try {\n    const result = await parquetQuery({\n      metadata, file, rowStart, rowEnd, orderBy, compressors,\n    })\n    self.postMessage({ result })\n  } catch (error) {\n    self.postMessage({ error })\n  }\n}\n"],"names":["ParquetType","Encoding","undefined","FieldRepetitionType","ConvertedType","CompressionCodec","PageType","dayMillis","convertWithDictionary","data","dictionary","schemaElement","encoding","utf8","endsWith","convert","output","Uint8Array","constructor","length","i","ctype","converted_type","scale","factor","Math","pow","arr","Array","parseDecimal","Number","type","from","map","parseInt96Date","Date","decoder","TextDecoder","v","JSON","parse","decode","Error","BigUint64Array","BigInt","logical_type","parseFloat16","unit","bytes","value","byte","days","nano","int16","sign","exp","frac","NaN","Infinity","schemaTree","schema","rootIndex","path","element","children","count","num_children","childElement","child","name","push","getSchemaPath","tree","part","find","getMaxRepetitionLevel","schemaPath","maxLevel","repetition_type","getMaxDefinitionLevel","slice","CompactType","deserializeTCompactProtocol","reader","lastFid","offset","view","byteLength","fid","newLastFid","readFieldBegin","readElement","getInt8","zigzag","readVarInt","readZigZag","readZigZagBigInt","getFloat64","stringLength","strBytes","buffer","byteOffset","elemType","listSize","sizeType","getUint8","size","getCompactType","readCollectionBegin","boolType","values","structValues","structLastFid","structFieldType","structFid","uuid","toString","padStart","result","shift","readVarBigInt","delta","async","parquetMetadataAsync","asyncBuffer","initialFetchSize","footerOffset","max","footerBuffer","footerView","DataView","getUint32","metadataLength","metadataOffset","metadataBuffer","combinedBuffer","ArrayBuffer","combinedView","set","parquetMetadata","arrayBuffer","metadataLengthOffset","metadata","version","field_1","field_2","field","type_length","field_3","field_4","field_5","field_6","field_7","precision","field_8","field_id","field_9","logicalType","field_10","columnSchema","filter","e","num_rows","row_groups","rowGroup","columns","column","columnIndex","file_path","file_offset","meta_data","encodings","path_in_schema","codec","num_values","total_uncompressed_size","total_compressed_size","key_value_metadata","data_page_offset","index_page_offset","dictionary_page_offset","field_11","statistics","convertStats","field_12","encoding_stats","field_13","encodingStat","page_type","bloom_filter_offset","field_14","bloom_filter_length","field_15","size_statistics","field_16","unencoded_byte_array_data_bytes","repetition_level_histogram","definition_level_histogram","offset_index_offset","offset_index_length","column_index_offset","column_index_length","crypto_metadata","encrypted_column_metadata","total_byte_size","sorting_columns","sortingColumn","column_idx","descending","nulls_first","ordinal","keyValue","key","created_by","metadata_length","isAdjustedToUTC","timeUnit","bitWidth","isSigned","stats","convertMetadata","min","null_count","distinct_count","max_value","min_value","is_max_value_exact","is_min_value_exact","getFloat32","getInt32","getBigInt64","assembleLists","definitionLevels","repetitionLevels","repetitionPath","maxDefinitionLevel","n","valueIndex","containerStack","currentContainer","currentDepth","currentDefLevel","currentRepLevel","at","def","rep","pop","newList","assembleNested","subcolumnData","depth","join","optional","nextDepth","firstChild","isListLike","sublist","subDepth","subcolumn","get","flattenAtDepth","delete","keyChild","valueChild","isMapLike","mapName","keys","out","assembleMaps","invertDepth","struct","childData","inverted","invertStruct","obj","j","Object","clz32","readRleBitPackedHybrid","width","seen","header","readBitPacked","readRle","mask","left","right","byteStreamSplit","typeLength","byteWidth","b","Float32Array","Float64Array","Int32Array","BigInt64Array","split","subarray","readPlain","fixedLength","bitOffset","ceil","readPlainBoolean","align","readPlainInt32","readPlainInt64","low","high","readPlainInt96","readPlainFloat","readPlainDouble","readPlainByteArray","readPlainByteArrayFixed","aligned","WORD_MASK","copyBytes","fromArray","fromPos","toArray","toPos","selfCopyBytes","array","pos","readDataPage","daph","dataPage","maxRepetitionLevel","readRepetitionLevels","numNulls","readDefinitionLevels","nValues","readDictionaryPage","diph","columnMetadata","decompressPage","compressedBytes","uncompressed_page_size","compressors","page","customDecompressor","input","inputLength","outputLength","outPos","c","len","isNaN","lengthSize","snappyUncompress","deltaBinaryUnpack","int32","blockSize","miniblockPerBlock","outputIndex","valuesPerMiniblock","minDelta","bitWidths","bitpackPos","miniblockCount","bits","readDataPageV2","ph","daph2","data_page_header_v2","repetition_levels_byte_length","readRepetitionLevelsV2","definition_levels_byte_length","readDefinitionLevelsV2","uncompressedPageSize","is_compressed","pageView","pageReader","num_nulls","x","lengths","deltaLengthByteArray","prefixData","suffixData","suffix","deltaByteArray","parquetHeader","compressed_page_size","crc","data_page_header","definition_level_encoding","repetition_level_encoding","index_page_header","dictionary_page_header","is_sorted","concat","aaa","bbb","asyncBufferFromUrl","url","fetch","method","then","res","ok","status","headers","parseInt","byteLengthFromUrl","start","end","Headers","endStr","body","readColumn","rowLimit","rowData","getColumnRange","columnOffset","readRowGroup","options","groupStart","file","groupBuffer","groupStartByte","groupEndByte","forEach","includes","columnStartByte","columnEndByte","promises","subcolumnNames","Map","getSubcolumns","columnName","columnBytes","console","warn","toLocaleString","bufferOffset","Promise","resolve","columnData","subcolumns","every","has","onChunk","rowStart","rowEnd","all","onComplete","groupData","includedColumnNames","columnOrder","includedColumns","row","rowFormat","index","parquetQuery","orderBy","orderColumn","parquetReadObjects","sortedIndices","_","sort","a","compare","sparseData","rows","rowGroups","groupIncluded","fill","groupEnds","group","findIndex","rowRanges","rangeStart","groupEnd","rangeEnd","__index__","parquetReadRows","reject","groupRows","parquetRead","catch","ab","u8","u16","Uint16Array","i16","Int16Array","i32","slc","s","prototype","call","cpw","t","copyWithin","ec","err","ind","msg","nt","code","captureStackTrace","rb","d","o","rzfh","dat","w","n3","flg","ss","cc","df","fcf","bt","db","di","fsb","fss","ws","wb","buf","y","l","u","m","msb","val","rfse","mal","tpos","al","sz","probs","sym","re","ht","freq","dstate","nstate","bb1","syms","nbits","cbt","msk","msk1fb","msv","sval","rbt","sympos","sstep","smask","sf","ns","nb","dllt","dmlt","doct","b2bl","bl","llb","llbl","mlb","mlbl","dhu","hu","lb","eb","st","btr","dhu4","sz1","sz2","sz3","rzb","_a","b0","btype","ebt","b3","lbt","lss","lcs","s4","spl","h","hud","wc","hb","hw","rc","ri","fdt","epos","st1","st2","btr1","btr2","fpos","wes","wt","mb","ts","rem","hbuf","pv","rhu","scm","dts","md","rbuf","_b","mlt","oct","llt","spos","oubt","lst","ost","mst","llc","lbtr","mlc","mbtr","ofc","obtr","ofp","off","ml","ll","idx","stin","bs","decompress","bufs","ol","blk","chk","cct","wasm64","BROTLI_READ_SIZE","kBitMask","Uint32Array","BrotliBitReader","this","buf_","input_","buf_ptr_","val_","pos_","reset","READ_SIZE","IBUF_MASK","bit_pos_","bit_end_pos_","eos_","readMoreInput","dst","bytes_read","read","p","fillBitWindow","readBits","n_bits","lookup","lookupOffsets","kCodeLengthCodeOrder","HuffmanCode","MAX_LENGTH","getNextKey","step","replicateValue","table","nextTableBitSize","root_bits","buildHuffmanTable","root_table","code_lengths","code_lengths_size","start_table","sorted","table_bits","table_size","total_size","symbol","readHuffmanCode","alphabet_size","tables","br","simple_code_or_skip","max_bits_counter","max_bits","symbols","num_symbols","code_length_code_lengths","space","num_codes","huff","code_len_idx","prev_code_len","repeat","repeat_code_len","code_len","extra_bits","new_len","old_repeat","repeat_delta","readHuffmanCodeLengths","readSymbol","PrefixCodeRange","kBlockLengthPrefixCode","kInsertLengthPrefixCode","kCopyLengthPrefixCode","kInsertRangeLut","kCopyRangeLut","BrotliInput","BrotliOutput","write","fixedLengthExtraBits","fixedDistanceExtraBits","codeLengthIndexMap","freb","base","rev","fl","revfl","fd","huffMap","cd","maxBits","r","le","co","rvb","sv","freeBits","startValue","endValue","fixedLengthTree","fixedDistanceTree","fixedLengthMap","fixedDistanceMap","bits16","gunzip","inputIndex","payloadStart","flag","zs","gzipStart","lmap","dmap","final","lengthBits","distBits","totalBits","hLiteral","hcLengths","tl","lengthDistanceTree","codeLengthTree","codeLengthBits","clbMask","codeLengthMap","copy","lengthTree","distanceTree","lms","dms","lpos","add","dsym","dt","getDictionary","gzipString","atob","gzipBytes","charCodeAt","kUppercaseFirst","kUppercaseAll","Transform","prefix","transform","kTransforms","kNumTransforms","ToUpperCase","transformDictionaryWord","word","skip","start_idx","prefix_pos","uppercase","suffix_pos","HUFFMAN_MAX_TABLE_SIZE","kDistanceShortCodeIndexOffset","kDistanceShortCodeValueOffset","Int8Array","kMaxHuffmanTableSize","offsetsByLength","sizeBitsByLength","decodeBlockType","max_block_type","trees","tree_type","block_types","ringbuffers","indexes","ringbuffer","type_code","block_type","HuffmanTreeGroup","num_htrees","codes","htrees","readBlockLength","translateShortCodes","copyUncompressedBlockToOutput","ringbuffer_mask","rb_size","rb_pos","br_pos","nbytes","tail","decodeVarLenUint8","MetaBlockLength","meta_block_length","input_end","is_uncompressed","is_metadata","DecodeMetaBlockLength","size_nibbles","size_bytes","next_byte","next_nibble","DecodeContextMap","context_map_size","max_run_length_prefix","context_map","reps","v_len","mtf","moveToFront","inverseMoveToFrontTransform","jumpToByteBoundary","new_bit_pos","lz4basic","token","literals","matchLength","next","SNAPPY","wasm","binaryString","byteArray","mod","WebAssembly","Module","Instance","instantiateWasm","memory","uncompress","exports","inputStart","outputStart","totalSize","pageSize","currentPages","pagesToGrow","grow","snappyUncompressor","GZIP","BROTLI","window_bits","max_distance","dist_rb","dist_rb_idx","prev_byte1","prev_byte2","hgroup","kRingBufferWriteAheadSlack","decodeWindowBits","max_backward_distance","ringbuffer_size","ringbuffer_end","block_type_trees","block_len_trees","meta_block_remaining_len","block_length","num_block_types","block_type_rb","block_type_rb_index","context_offset","_out","tmp","distance_postfix_bits","num_direct_distance_codes","distance_postfix_mask","num_distance_codes","context_modes","_o1","num_literal_htrees","_o2","num_dist_htrees","dist_context_map","context_map_slice","dist_context_map_slice","context_mode","context_lookup_offset1","context_lookup_offset2","htree_command","distance_code","cmd_code","range_idx","insert_code","copy_code","insert_length","copy_length","literal_htree_index","dist_htree_index","postfix","distance","copy_dst","word_id","transform_idx","_x","brotli","ZSTD","LZ4","expectedOutputLength","expectedInputLength","error","message","LZ4_RAW","self","onmessage","postMessage"],"mappings":"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,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,EAE5D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAE7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAG7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAE7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAE7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAE7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAE7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAClD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAClD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAClD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAClD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GACpD,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAC5D,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAE5D,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAC7C,EAAG,EAAG,EAAG,EAAG,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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]}